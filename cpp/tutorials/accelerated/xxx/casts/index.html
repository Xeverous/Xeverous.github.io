<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!-- Enable responsiveness on mobile devices--><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title>modern C++ by Xeverous - casts</title>
<link rel="icon" href="favicon.png">
<!-- RSS --><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../../../atom.xml">
<!-- CSS --><link rel="stylesheet" href="../../../../../assets/css/styles.css">
<!-- JS --><script type="text/javascript" src="../../../../../assets/js/app.js" defer></script><!-- maybe later
	<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']]
    },
    showMathMenu: false,
    menuSettings: {
      zoom: "None",
      collapsible: false,
      autocollapse: false,
      explorer: false
    }
  });
        </script>
	<script type="text/javascript" async
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"
		async></script>
	-->
</head>
<body>
	<div class="layout">
 <nav class="sidebar"><ul>
<li class="sidebar-section">
			<ul>
<li><a href="../../../../../">HOME</a></li>
				<li><a href="../../../../../index">INDEX</a></li>
			</ul>
</li>

			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ tutorials</h4>
				<p class="sidebar-section-description">Learn C++ from begin() to the end() (and beyond) or use knowledge and experience gained in other languages in the accelerated tutorial.</p>

				<ul>
<li><a href="../../../beginner/">beginner</a></li>
						<li><a href="../../">accelerated</a></li>
						<li><a href="../../../templates/">templates</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ how-to</h4>
				<p class="sidebar-section-description">Common and specific tasks explained.</p>

				<ul>
<li><a href="../../../../stdlib/">standard library components</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ utilities</h4>
				<p class="sidebar-section-description">Various metarials with concentrated information.</p>

				<ul>
<li><a href="../../../../utility/cheatsheets/">C++ cheatsheets</a></li>
						<li><a href="../../../../utility/cpp_faq/">C++ FAQ</a></li>
						<li><a href="../../../../utility/cpp_myths/">C++ myths</a></li>
						<li><a href="../../../../utility/glossary/">glossary</a></li>
						<li><a href="../../../../utility/">(all articles)</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">misc / meta</h4>
				<p class="sidebar-section-description">About this website and its authors.</p>

				<ul>
<li><a href="../../../../../about/">about</a></li>
						<li><a href="../../../../../meta/site_faq/">website FAQ</a></li>
						<li><a href="../../../../../meta/markdown_test/">Markdown test page</a></li>
						<li><a href="../../../../../meta/rest_test/">reStructuredText test page</a></li>
				</ul>
</li>
	</ul></nav><nav class="topbar"><ul class="menu">
<li class="button"><a href="../../../../../">HOME</a></li>
				<li class="button"><a href="../../../../../index">INDEX</a></li>
				<li class="button"><a href="../../../../../faq">FAQ</a></li>
				<li class="button"><a href="../../../../../about">ABOUT</a></li>
				<li class="button menu-button">
					<div class="menu-icon">
						<div class="bar1"></div>
						<div class="bar2"></div>
						<div class="bar3"></div>
					</div>
				</li>
			</ul></nav><div class="main container">
				<nav class="breadcrumb"><ol>
<li><a href="../../../../../index">index</a></li>
						<span>/</span>
							<li><a href="../../../../">C++</a></li>
							<span>/</span>
							<li><a href="../../../">tutorials</a></li>
							<span>/</span>
							<li><a href="../../">accelerated</a></li>
							<span>/</span>
							<li><a href="../">unsorted articles</a></li>
							<span>/</span>
						<li>casts</li>
					</ol></nav><div class="content">
				<h1>casts</h1>				<aside class="admonition note"><p class="admonition-title">note</p>
<p>All casts in this article are forms of <em>explicit convertion</em>. Implicit convertion is explained in a different article.</p>
</aside><p>In many languages, the syntax to convert an object is <code class="code custom-cpp">(<span class="param-tmpl">T</span>) <span class="spec">expression</span></code> or <code class="code custom-cpp"><span class="param-tmpl">T</span>(<span class="spec">expression</span>)</code>. Both are also valid in C++ (for backwards compatibility), but <strong>discouraged</strong>.</p>
<p>C++ has 4 keywords dedicated for casts, each with distinct behavior. In C++11 they have been modernized. Why all of these? There are multiple reasons:</p>
<ul class="simple">
<li><p>C++ is a complex language that can work on multiple levels of abstraction. There are situations where multiple ways of converting an object are possible so a single way of writing is not enough.</p></li>
<li><p>Cast keywords are very clear about their intent.</p></li>
<li><p>Cast keywords produce better compiler errors because each has narrowed set of rules.</p></li>
<li><p>It's easy to make a mistake with old casts, including ones that invoke undefined behavior.</p></li>
<li><p>One of old casts has a grammar problem - it accepts only <em>simple-type-specifier</em> or a <em>typedef-specifier</em> (less technically: a single-word type name), for example <code class="code custom-cpp"><span class="keyword">long</span> <span class="keyword">long</span>(<span class="spec">expression</span>)</code> and <code class="code custom-cpp"><span class="keyword">int</span>*(<span class="spec">expression</span>)</code> are not valid.</p></li>
</ul>
<section id="old-casts"><h2>Old casts</h2>
<ul class="simple">
<li><p>Casts inherited from C, they take the form <code class="code custom-cpp">(<span class="param-tmpl">T</span>) <span class="spec">expression</span></code>.</p></li>
<li><p><em>functional cast expressions</em> (not present in C), they take the form <code class="code custom-cpp"><span class="param-tmpl">T</span>(<span class="spec">expression</span>)</code>. Depending on the type, the same syntax can also mean a constructor call.</p></li>
</ul>
<p>Both of these work the same (apart from grammar issues which block some usages). Put shortly, they will pick behavior identical to one of keyword casts. The picking <a class="reference external" href="https://en.cppreference.com/w/cpp/language/explicit_cast">is quite complex</a> and <a class="reference external" href="https://anteru.net/blog/2007/c-background-static-reinterpret-and-c-style-casts/">there is an article describing a case where included files can affect behavior</a>. You certainly do not want to experience undefined behavior just because of changes in some (potentially transitively) included header files.</p>
<p>So ... simply don't use these casts in C++11 (and later) code. The only widely accepted old cast is explicit discard of the result: <code class="code custom-cpp">(<span class="keyword">void</span>) <span class="spec">expression</span></code>. It relies on the fact that anything can be converted to void type - this cast should be used purely to shut warnings about unused variables (usually unused function parameters when commenting out name is not feasible if they are used on a different build configuration - different target platform or debug/release).</p>
</section><section id="cast-keywords"><h2>Cast keywords</h2>
<p>The cast keywords are:</p>
<ul class="simple">
<li><p><code class="code custom-cpp"><span class="keyword">static_cast</span>&lt;<span class="param-tmpl">T</span>&gt;(<span class="spec">expression</span>)</code></p></li>
<li><p><code class="code custom-cpp"><span class="keyword">dynamic_cast</span>&lt;<span class="param-tmpl">T</span>&gt;(<span class="spec">expression</span>)</code></p></li>
<li><p><code class="code custom-cpp"><span class="keyword">const_cast</span>&lt;<span class="param-tmpl">T</span>&gt;(<span class="spec">expression</span>)</code></p></li>
<li><p><code class="code custom-cpp"><span class="keyword">reinterpret_cast</span>&lt;<span class="param-tmpl">T</span>&gt;(<span class="spec">expression</span>)</code></p></li>
</ul>
<p>Apart from solving ambiguity and code clarity problems, a big advantage of these keywords is that they look exactly like function templates - new casts can be added with the same syntax. Some already exist:</p>
<ul class="simple">
<li><p>C++20 <code class="code custom-cpp"><span class="namespace">std</span>::<span class="func">bit_cast</span></code> - obtains value of type <code class="code custom-cpp"><span class="param-tmpl">T</span></code> by reinterpreting object representation. This could be thought as a short form of specific usage of <code class="code custom-cpp"><span class="keyword">reinterpret_cast</span></code> but the bit cast guarantees no <em>aliasing</em> violations while the keyword alone does not. It's also <code class="code custom-cpp"><span class="keyword">constexpr</span></code>.</p></li>
<li><p><code class="code custom-cpp"><span class="namespace">boost</span>::<span class="func">lexical_cast</span></code> (string to number and number to string)</p></li>
<li><p><code class="code custom-cpp"><span class="namespace">boost</span>::<span class="func">numeric_cast</span></code> (number to number)</p></li>
</ul></section><section id="code-class-code-custom-cpp-span-class-keyword-static-cast-span-code"><h2><code class="code custom-cpp"><span class="keyword">static_cast</span></code></h2>
<p>The keyword is used for all typical convertions that rely on compile time information. It's by far the most used explicit convertion keyword.</p>
<p>The cast does not modify the source object, it creates a new object thus the source object can be <code class="code custom-cpp"><span class="keyword">const</span></code>. Possible convertions:</p>
<ul class="simple">
<li><p>all implicit convertions</p></li>
<li><p><code class="code custom-cpp"><span class="keyword">enum</span></code> to <code class="code custom-cpp"><span class="keyword">bool</span></code>, integer or floating-point type and reverse of it</p></li>
<li><p>bit-field to its underlying type</p></li>
<li><p>anything to <code class="code custom-cpp"><span class="keyword">void</span></code> (usually to shut compiler warnings about unused variables)</p></li>
<li><p>constructor calls if the destination type is a class, additional implicit convertions are allowed in such case</p></li>
<li><p>call to user-defined convertion operator - classes can overload <code class="code custom-cpp"><span class="keyword">operator</span> <span class="param-tmpl">T</span></code> to enable such convertions, many overload <code class="code custom-cpp"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="keyword">bool</span></code> to support code like <code class="code custom-cpp"><span class="keyword">if</span> (<span class="var-local">obj</span>)</code></p></li>
<li><p>pointer/reference inheritance casts (these only create a new pointer/reference, they do not modify the pointed/referenced object)</p></li>
<li><p>(possibly cv-qualified) <code class="code custom-cpp"><span class="keyword">void</span>*</code> to any pointer to an object type (function pointers are not object pointers) that is not less cv-qualified</p></li>
</ul>
<section id="enumerations"><h3>Enumerations</h3>
<p>An integer or floating point may be converted to <code class="code custom-cpp"><span class="keyword">enum</span></code> even if the enumeration has no such value. It will not be adjusted and will compare <code class="code custom-cpp"><span class="keyword">false</span></code> with any enumerator. If the <code class="code custom-cpp"><span class="keyword">enum</span></code> has no fixed underlying type, the largest allowed value is the is the largest representable value in the smallest bitfield capable of holding enumeration values.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="com-single">// max value depends on range of type int</span>
<span class="keyword">enum</span> <span class="keyword">class</span> <span class="type">fixed</span> : <span class="keyword">int</span> { <span class="enum">one</span> = <span class="lit-num">1</span>, <span class="enum">two</span>, <span class="enum">three</span>, <span class="enum">last</span> = <span class="lit-num">30</span> };
<span class="com-single">// max value = 31 (30 requires bit-field of 5 bits, which has range [0, 31])</span>
<span class="keyword">enum</span> <span class="keyword">class</span> <span class="type">not_fixed</span> { <span class="enum">one</span> = <span class="lit-num">1</span>, <span class="enum">two</span>, <span class="enum">three</span>, <span class="enum">last</span> = <span class="lit-num">30</span> };

<span class="keyword">auto</span> <span class="var-local">e1</span> = <span class="keyword">static_cast</span>&lt;<span class="type">fixed</span>&gt;(<span class="lit-num">31</span>);     <span class="com-single">// well-defined</span>
<span class="keyword">auto</span> <span class="var-local">e2</span> = <span class="keyword">static_cast</span>&lt;<span class="type">fixed</span>&gt;(<span class="lit-num">50</span>);     <span class="com-single">// well-defined</span>
<span class="keyword">auto</span> <span class="var-local">e3</span> = <span class="keyword">static_cast</span>&lt;<span class="type">not_fixed</span>&gt;(<span class="lit-num">31</span>); <span class="com-single">// well-defined</span>
<span class="keyword">auto</span> <span class="var-local">e4</span> = <span class="keyword">static_cast</span>&lt;<span class="type">not_fixed</span>&gt;(<span class="lit-num">50</span>); <span class="com-single">// undefined behavior</span>
</pre></td>
</tr></tbody></table></section><section id="type-upcasts"><h3>Type upcasts</h3>
<p>A pointer/reference to derived class may be converted to a pointer/reference to the base class.</p>
<ul class="simple">
<li><p>the cast is <em>ill-formed</em> if base is ambiguous (multiple inheritance can result in one type being inherited from multiple times)</p></li>
<li><p>the cast is <em>ill-formed</em> if base is inaccessible (private or protected inheritance)</p></li>
<li><p>if the pointer is null the resulting pointer is also null</p></li>
</ul>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">struct</span> <span class="type">base</span> {};
<span class="keyword">struct</span> <span class="type">derived</span> : <span class="type">base</span> {};
<span class="keyword">struct</span> <span class="type">extra_derived</span> : <span class="type">derived</span>, <span class="type">base</span> {};
<span class="keyword">struct</span> <span class="type">privately_derived</span> : <span class="keyword">private</span> <span class="type">base</span> {};

<span class="type">extra_derived</span> <span class="var-local">ed</span>;
<span class="keyword">static_cast</span>&lt;<span class="type">derived</span>&amp;&gt;(<span class="var-local">ed</span>);  <span class="com-single">// well-defined</span>
<span class="keyword">static_cast</span>&lt;<span class="type">derived</span>*&gt;(&amp;<span class="var-local">ed</span>); <span class="com-single">// well-defined</span>

<span class="keyword">static_cast</span>&lt;<span class="type">base</span>&amp;&gt;(<span class="var-local">ed</span>);  <span class="com-single">// error: base is ambiguous</span>
<span class="keyword">static_cast</span>&lt;<span class="type">base</span>*&gt;(&amp;<span class="var-local">ed</span>); <span class="com-single">// error: base is ambiguous</span>

<span class="type">privately_derived</span> <span class="var-local">pd</span>;
<span class="keyword">static_cast</span>&lt;<span class="type">base</span>&amp;&gt;(<span class="var-local">pd</span>);  <span class="com-single">// error: base is inaccessible</span>
<span class="keyword">static_cast</span>&lt;<span class="type">base</span>*&gt;(&amp;<span class="var-local">pd</span>); <span class="com-single">// error: base is inaccessible</span>
</pre></td>
</tr></tbody></table>
<aside class="admonition note"><p class="admonition-title">note</p>
<p>These upcasts can also be performed implicitly.</p>
</aside></section><section id="type-downcasts"><h3>Type downcasts</h3>
<p>A pointer/reference to base class may be converted to a pointer/reference to the derived class.</p>
<aside class="admonition error"><p class="admonition-title">error</p>
<p>No runtime checks are performed to check that the pointed/referenced object is actually of the derived type. If it's not, the behavior is undefined. If checks are needed, <code class="code custom-cpp"><span class="keyword">dynamic_cast</span></code> should be used.</p>
</aside><p>The cast has same ambiguity and accessibility preconditions as the upcast, but additionally the cast is <em>ill-formed</em> if base is a virtual base or a base of virtual base of derived - in such case <code class="code custom-cpp"><span class="keyword">dynamic_cast</span></code> is needed.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">struct</span> <span class="type">base</span> {};
<span class="keyword">struct</span> <span class="type">derived</span> : <span class="type">base</span> {};
<span class="keyword">struct</span> <span class="type">virtually_derived</span> : <span class="keyword">virtual</span> <span class="type">base</span> {};

<span class="type">derived</span> <span class="var-local">d</span>;
<span class="type">base</span>&amp; <span class="var-local">br</span> = <span class="d">d</span>;
<span class="keyword">static_cast</span>&lt;<span class="type">derived</span>&amp;&gt;(<span class="var-local">br</span>);  <span class="com-single">// well-defined</span>
<span class="keyword">static_cast</span>&lt;<span class="type">derived</span>*&gt;(&amp;<span class="var-local">br</span>); <span class="com-single">// well-defined</span>

<span class="type">base</span> <span class="var-local">b</span>;
<span class="keyword">static_cast</span>&lt;<span class="type">derived</span>&amp;&gt;(<span class="var-local">b</span>);  <span class="com-single">// undefined behavior</span>
<span class="keyword">static_cast</span>&lt;<span class="type">derived</span>*&gt;(&amp;<span class="var-local">b</span>); <span class="com-single">// undefined behavior</span>

<span class="keyword">static_cast</span>&lt;<span class="type">virtually_derived</span>&amp;&gt;(<span class="var-local">br</span>);  <span class="com-single">// error: virtual inheritance is present</span>
<span class="keyword">static_cast</span>&lt;<span class="type">virtually_derived</span>*&gt;(&amp;<span class="var-local">br</span>); <span class="com-single">// error: virtual inheritance is present</span>
</pre></td>
</tr></tbody></table>
<p>Because of undefined behavior risk, <code class="code custom-cpp"><span class="keyword">static_cast</span></code> downcasts must guarantee through other means that the object is in fact of derived type - usually the base class has a <code class="code custom-cpp"><span class="keyword">virtual</span></code> method which returns unique value for each type (basically manual and simplified implementation of RTTI).</p>
</section><section id="member-pointer-upcasts"><h3>Member pointer upcasts</h3>
<p>A pointer to member of derived class can be converted to a pointer to member of the base class. <strong>The cast makes no checks to ensure the member actually exists in the runtime type of the pointed-to/referenced object.</strong></p>
<ul class="simple">
<li><p>the cast is <em>ill-formed</em> if base is ambiguous</p></li>
<li><p>the cast is <em>ill-formed</em> if base is inaccessible</p></li>
<li><p>if the pointer is null the resulting pointer is also null</p></li>
</ul>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">struct</span> <span class="type">base</span> {};
<span class="keyword">struct</span> <span class="type">derived</span> : <span class="type">base</span> { <span class="keyword">int</span> <span class="var-member">m</span> = <span class="lit-num">42</span>; };

<span class="type">derived</span> <span class="var-local">d</span>;
<span class="keyword">int</span> <span class="type">derived</span>::* <span class="var-local">d_pm</span> = &amp;<span class="type">derived</span>::<span class="var-member">m</span>;
<span class="keyword">auto</span> <span class="var-local">b_pm</span> = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> <span class="type">base</span>::*&gt;(<span class="var-local">d_pm</span>); <span class="com-single">// well-defined</span>
<span class="var-local">d</span>.*<span class="var-local">b_pm</span>; <span class="com-single">// well-defined</span>

<span class="type">base</span> <span class="var-local">b</span>;
<span class="var-local">b</span>.*<span class="var-local">b_pm</span>; <span class="com-single">// undefined behavior (the runtime object has no such member)</span>
</pre></td>
</tr></tbody></table></section><section id="member-pointer-downcasts"><h3>Member pointer downcasts</h3>
<p>A pointer to member of base class can be converted to a pointer to member of the derived class.</p>
<ul class="simple">
<li><p>the cast is <em>ill-formed</em> if base is ambiguous</p></li>
<li><p>the cast is <em>ill-formed</em> if base is inaccessible</p></li>
<li><p>the cast is <em>ill-formed</em> if base is a virtual base or a base of virtual base of derived class</p></li>
<li><p>if the pointer is null the resulting pointer is also null</p></li>
</ul>
<aside class="admonition note"><p class="admonition-title">note</p>
<p>These upcasts can also be performed implicitly.</p>
</aside></section><section id="more-on-pointers"><h3>More on pointers</h3>
<!-- TODO move pointer convertions to pointers chapter? This article deals with inheritance only but pointers have many more convertions (void*, interconvertibility, aliasing, cv-qualifiers) -->
<!-- TODO mention: Static casts can not be used for int-to-string or string-to-int convertions since they involve a class type. Standard library offers multiple parsing functions instead. -->
<aside class="admonition note"><p class="admonition-title">note</p>
<p>Pointers to data members have the same convertion rules as pointers to function members.</p>
</aside><aside class="admonition note"><p class="admonition-title">note</p>
<p>Pointers to members are hardly ever used.</p>
</aside><!--  --><blockquote>
<p>I don't get why while pointer <strong>upcasts</strong> are implicit, pointer to member <strong>downcasts</strong> are implicit.</p>
</blockquote>
<p>Pointer/reference upcasts are simple: every derived object also has a base subobject. Not so in reverse.</p>
<p>Pointer to member downcasts are safe because every derived class also has members of the base class. Not so in reverse.</p>
</section><section id="sidecasts"><h3>Sidecasts</h3>
<p>Sidecasts with <code class="code custom-cpp"><span class="keyword">static_cast</span></code> are not possible. An upcast has to be made first and then a downcast.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">struct</span> <span class="type">base</span> {};
<span class="keyword">struct</span> <span class="type">left</span> : <span class="type">base</span> {};
<span class="keyword">struct</span> <span class="type">right</span> : <span class="type">base</span> {};
<span class="keyword">struct</span> <span class="type">derived</span> : <span class="type">left</span>, <span class="type">right</span> {};

<span class="type">derived</span> <span class="var-local">d</span>;
<span class="type">left</span>&amp; <span class="var-local">l</span> = <span class="var-local">d</span>;
<span class="keyword">static_cast</span>&lt;<span class="type">right</span>&amp;&gt;(<span class="var-local">l</span>); <span class="com-single">// error: invalid cast</span>

<span class="com-single">// Valid, but actually performs reinterpret_cast.</span>
<span class="com-single">// Would perform static_cast if such was valid</span>
<span class="com-single">// (another reason not to use old casts, changes</span>
<span class="com-single">// in inheritance can cause undefined behavior).</span>
(<span class="type">right</span>&amp;) <span class="var-local">l</span>;
</pre></td>
</tr></tbody></table></section><section id="overload-sets"><h3>Overload sets</h3>
<p>One very practical use of <code class="code custom-cpp"><span class="keyword">static_cast</span></code> is selecting a specific function overload to resolve an ambiguity.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="param-tmpl">F</span>, <span class="keyword">typename</span>... <span class="param-tmpl">Args</span>&gt;
<span class="keyword">auto</span> <span class="func">invoke</span>(<span class="param-tmpl">F</span> <span class="param">f</span>, <span class="param-tmpl">Args</span>&amp;&amp;... <span class="param">args</span>);

<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">int</span>, <span class="keyword">int</span>);
<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">double</span>, <span class="keyword">double</span>);

<span class="func">invoke</span>(<span class="func">f</span>, <span class="lit-num">1</span>, <span class="lit-num">2</span>); <span class="com-single">// error: can not deduce F</span>
<span class="func">invoke</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>(&amp;)(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;(<span class="func">f</span>), <span class="lit-num">1</span>, <span class="lit-num">2</span>); <span class="com-single">// ok</span>
</pre></td>
</tr></tbody></table>
<p>It can be made even simpler by introducing a helper function template:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="param-tmpl">F</span>&gt; <span class="keyword">constexpr</span>
<span class="param-tmpl">F</span>&amp; <span class="func">select_overload</span>(<span class="param-tmpl">F</span>&amp; <span class="param">f</span>) <span class="keyword">noexcept</span> { <span class="keyword">return</span> <span class="param">f</span>; }

<span class="func">invoke</span>(<span class="func">select_overload</span>&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;(<span class="func">f</span>), <span class="lit-num">1</span>, <span class="lit-num">2</span>); <span class="com-single">// ok</span>
</pre></td>
</tr></tbody></table>
<!--  --><blockquote>
<p>Why there is no <code class="docutils literal">(&amp;)</code> in the second example?</p>
</blockquote>
<p>The first example casts the function overload set to a reference to a function of specific type (a function type would be invalid because functions can not be taken by value), the second example has the reference built into the template.</p>
<blockquote>
<p>Why then the first function takes a function argument by value?</p>
</blockquote>
<p>It's not a <em>function</em> but a <em>function template</em>.</p>
<blockquote>
<p>Why then the first function template takes a function argument by value?</p>
</blockquote>
<p>It does not because it's a <em>function template</em> and the <em>template parameter</em> is a subject to <em>template type deduction</em>. The <em>deduced type</em> may be a <em>reference</em> type.</p>
<blockquote>
<p>Why is dedu...</p>
</blockquote>
<p>Go learn templates in their dedicated tutorial!</p>
</section></section><section id="code-class-code-custom-cpp-span-class-keyword-dynamic-cast-span-code"><h2><code class="code custom-cpp"><span class="keyword">dynamic_cast</span></code></h2>
<p>This keyword is intended for inheritance casts.</p>
<p>Like <code class="code custom-cpp"><span class="keyword">static_cast</span></code>, this cast can also perform some convertions that are allowed implicitly (most notably upcast and adding cv-qualifiers).</p>
<section id="requirements"><h3>Requirements</h3>
<p>The result type can only be:</p>
<ul class="simple">
<li><p>pointer to class type</p></li>
<li><p>reference to class type</p></li>
<li><p>(possibly cv-qualified) <code class="code custom-cpp"><span class="keyword">void</span>*</code></p></li>
</ul>
<p>The input expression must be:</p>
<ul class="simple">
<li><p>reference to a class type if result type is a reference</p></li>
<li><p>pointer to a class type if the result type is a pointer</p></li>
</ul>
<p>The types involved must:</p>
<ul class="simple">
<li><p>be complete (forward declarations will result in compile errors)</p></li>
<li>
<p>analogically to <code class="code custom-cpp"><span class="keyword">static_cast</span></code>:</p>
<ul>
<li><p>there must be no ambiguity</p></li>
<li><p>there must be no inaccessibility</p></li>
</ul>
</li>
<li><p>be polymorphic when performing a downcast or a sidecast (such casts perform a runtime check which involves some overhead and requires RTTI - enabled by default in most compilers)</p></li>
</ul>
<p>If the cast is used on an object during construction or destruction and the result type is not a type matching the constructor/destructor or one of its bases, the behavior is undefined.</p>
</section><section id="results"><h3>Results</h3>
<ul class="simple">
<li><p>If the result type is a pointer and the input pointer is null or cast fails the result is a null pointer.</p></li>
<li><p>If the result type is a reference and the cast fails, an exception of type <code class="code custom-cpp"><span class="namespace">std</span>::<span class="type">bad_cast</span></code> or a type derived from it is thrown.</p></li>
</ul>
<p>The pointer version is strongly preferred. Use the reference version when you don't expect the cast to fail.</p>
</section><section id="examples"><h3>Examples</h3>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="com-single">// comment virtual dtor in base - compile error: types are not polymorphic</span>
<span class="com-single">// comment virtual inheritance - compile error: ambiguous base</span>
<span class="keyword">struct</span> <span class="type">base</span> { <span class="keyword">virtual</span> ~<span class="func">base</span>() = <span class="keyword">default</span>; };
<span class="keyword">struct</span> <span class="type">left</span> : <span class="keyword">virtual</span> <span class="type">base</span> {};
<span class="keyword">struct</span> <span class="type">right</span> : <span class="keyword">virtual</span> <span class="type">base</span> {};
<span class="keyword">struct</span> <span class="type">derived</span> : <span class="type">left</span>, <span class="type">right</span> {};

<span class="type">derived</span> <span class="var-local">d</span>;

<span class="com-single">// downcasts</span>
<span class="type">base</span>&amp; <span class="var-local">br</span> = <span class="var-local">d</span>;
<span class="type">derived</span>&amp; <span class="var-local">dr</span> = <span class="keyword">dynamic_cast</span>&lt;<span class="type">derived</span>&amp;&gt;(<span class="var-local">br</span>);
<span class="type">derived</span>* <span class="var-local">dp</span> = <span class="keyword">dynamic_cast</span>&lt;<span class="type">derived</span>*&gt;(&amp;<span class="var-local">br</span>);

<span class="com-single">// sidecasts</span>
<span class="type">left</span>&amp; <span class="var-local">lr</span> = <span class="var-local">d</span>;
<span class="type">right</span>&amp; <span class="var-local">rr</span> = <span class="keyword">dynamic_cast</span>&lt;<span class="type">right</span>&amp;&gt;(<span class="var-local">lr</span>);
<span class="type">right</span>* <span class="var-local">rp</span> = <span class="keyword">dynamic_cast</span>&lt;<span class="type">right</span>*&gt;(&amp;<span class="var-local">lr</span>);

<span class="com-single">// cast to void* (results in a pointer to most derived object)</span>
<span class="keyword">auto</span> <span class="var-local">vp</span> = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;<span class="var-local">br</span>);
</pre></td>
</tr></tbody></table>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">struct</span> <span class="type">base</span> { <span class="keyword">virtual</span> ~<span class="func">base</span>() = <span class="keyword">default</span>; };
<span class="keyword">struct</span> <span class="type">left</span> : <span class="keyword">virtual</span> <span class="type">base</span> {};
<span class="keyword">struct</span> <span class="type">right</span> : <span class="keyword">virtual</span> <span class="type">base</span>
{
	<span class="func">right</span>(<span class="type">base</span>* <span class="param">b</span>, <span class="type">left</span>* <span class="param">l</span>)
	{
		<span class="com-single">// casts during construction (see the call in the constructor of derived below)</span>

		<span class="com-single">// well-defined: right inherits base</span>
		<span class="keyword">dynamic_cast</span>&lt;<span class="type">right</span>*&gt;(<span class="param">b</span>);

		<span class="com-single">// right is not derived from left</span>
		<span class="com-single">// undefined behavior even if the final object inherits right</span>
		<span class="keyword">dynamic_cast</span>&lt;<span class="type">right</span>*&gt;(<span class="param">l</span>);
	}
};

<span class="keyword">struct</span> <span class="type">derived</span> : <span class="type">left</span>, <span class="type">right</span>
{
	<span class="func">derived</span>() : <span class="type">left</span>(<span class="keyword">static_cast</span>&lt;<span class="type">left</span>*&gt;(<span class="keyword">this</span>), <span class="keyword">this</span>) {}
};
</pre></td>
</tr></tbody></table></section><section id="questions"><h3>Questions</h3>
<blockquote>
<p>What if RTTI is disabled?</p>
</blockquote>
<p>Most compilers, if given <code class="docutils literal"><span class="pre">-fno-rtti</span></code> option (or equivalent) treat RTTI-requiring <code class="code custom-cpp"><span class="keyword">dynamic_cast</span></code> expressions as ill-formed. For more information see typeof article TOWRITE.</p>
<blockquote>
<p>Are <code class="code custom-cpp"><span class="keyword">static_cast</span></code> casts and <code class="code custom-cpp"><span class="keyword">dynamic_cast</span></code> upcasts only an abstraction? Do they compile to any machine instructions?</p>
</blockquote>
<p>They can. Apart from <em>padding</em> issues (caused by different <em>alignment</em> requirements) in case of <code class="code custom-cpp"><span class="keyword">virtual</span></code> base classes (even with no <code class="code custom-cpp"><span class="keyword">virtual</span></code> functions), the compiler may need to adjust <code class="code custom-cpp"><span class="keyword">this</span></code> pointer to correctly point to a subobject of specified type.</p>
</section></section><section id="code-class-code-custom-cpp-span-class-keyword-const-cast-span-code"><h2><code class="code custom-cpp"><span class="keyword">const_cast</span></code></h2>
<p>This cast can unconditionally add or remove <code class="code custom-cpp"><span class="keyword">const</span></code> and/or <code class="code custom-cpp"><span class="keyword">volatile</span></code> on:</p>
<ul class="simple">
<li><p>references</p></li>
<li><p>(potentially multilevel) pointers</p></li>
<li><p>(potentially multilevel) pointers to data members</p></li>
<li><p>(potentially multilevel) pointers to arrays of known bound</p></li>
<li><p>(potentially multilevel) pointers to arrays of unknown bound</p></li>
</ul>
<p>Pointers to functions and pointers to member functions are not subject to <code class="code custom-cpp"><span class="keyword">const_cast</span></code>.</p>
<p>The cast is designed to workaround issues with legacy code, particulary C code before C imported <code class="code custom-cpp"><span class="keyword">const</span></code> keyword from C++.</p>
<aside class="admonition error"><p class="admonition-title">error</p>
<p>The cast allows to form non-const references/pointers to <code class="code custom-cpp"><span class="keyword">const</span></code> objects and non-volatile references/pointers to <code class="code custom-cpp"><span class="keyword">volatile</span></code> objects. Modifying a <code class="code custom-cpp"><span class="keyword">const</span></code> object through a non-const access path and referring to a <code class="code custom-cpp"><span class="keyword">volatile</span></code> object through a non-volatile <em>glvalue</em> results in undefined behavior.</p>
</aside><p>In short, <strong>while the cast allows to strip</strong> <code class="code custom-cpp"><span class="keyword">const</span></code> <strong>and</strong> <code class="code custom-cpp"><span class="keyword">volatile</span></code><strong>, it still doesn't justify breaking related rules</strong>. It's purely to interact with troublesome non-cv-qualifier-correct legacy code.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="var-global">path</span> = <span class="lit-str">"/bin/sh"</span>;
<span class="keyword">int</span> <span class="func">legacy_interface</span>(<span class="keyword">char</span>* <span class="param">path</span>); <span class="com-single">// documentation: does not modify path</span>

<span class="keyword">int</span> <span class="var-local">err</span> = <span class="func">legacy_interface</span>(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="var-global">path</span>)); <span class="com-single">// ok if path is not modified</span>
</pre></td>
</tr></tbody></table>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">int</span> <span class="var-local">x</span> = <span class="lit-num">1</span>;
<span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="var-local">rx</span> = <span class="var-local">x</span>;
<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(<span class="var-local">rx</span>) = <span class="lit-num">2</span>; <span class="com-single">// ok: object is not actually const</span>

<span class="keyword">const</span> <span class="keyword">int</span> <span class="var-local">y</span> = <span class="lit-num">1</span>;
<span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="var-local">ry</span> = <span class="var-local">y</span>;
<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(<span class="var-local">ry</span>) = <span class="lit-num">2</span>; <span class="com-single">// undefined behavior</span>
</pre></td>
</tr></tbody></table>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">struct</span> <span class="type">test</span>
{
	<span class="keyword">int</span> <span class="var-member">m</span> = <span class="lit-num">0</span>;

	<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">int</span> <span class="param">v</span>) <span class="keyword">const</span>
	{
		<span class="com-single">// this-&gt;m = v;                 // ill-formed: this has type const test*</span>
		<span class="keyword">const_cast</span>&lt;<span class="type">test</span>*&gt;(<span class="keyword">this</span>)-&gt;<span class="var-member">m</span> = <span class="param">v</span>; <span class="com-single">// ok if *this is not a const object</span>
	}
};

<span class="type">test</span> <span class="var-local">t</span>;
<span class="var-local">t</span>.<span class="func">f</span>(<span class="lit-num">1</span>); <span class="com-single">// ok</span>

<span class="keyword">const</span> <span class="type">test</span> <span class="var-local">ct</span>;
<span class="var-local">ct</span>.<span class="func">f</span>(<span class="lit-num">1</span>); <span class="com-single">// invokes undefined behavior</span>

<span class="keyword">void</span> (<span class="type">test</span>::* <span class="var-local">pmf</span>)(<span class="keyword">int</span>) <span class="keyword">const</span> = &amp;<span class="type">test</span>::<span class="func">f</span>;
<span class="com-single">// ill-formed: can not cast member function constness</span>
<span class="com-single">// const_cast&lt;void(test::*)(int)&gt;(pmf);</span>
</pre></td>
</tr></tbody></table></section><section id="code-class-code-custom-cpp-span-class-keyword-reinterpret-cast-span-code"><h2><code class="code custom-cpp"><span class="keyword">reinterpret_cast</span></code></h2>
<p>Similarly to <code class="code custom-cpp"><span class="keyword">const_cast</span></code>, <code class="code custom-cpp"><span class="keyword">reinterpret_cast</span></code> does not compile to any machine instructions (except when converting between integers and pointers or on obscure architectures where pointer representation depends on its type). <strong>It is purely a compile time directive which instructs the compiler to treat expression as if it had a different type.</strong></p>
<p>Because the cast allows to explicitly violate the type system (except <code class="code custom-cpp"><span class="keyword">const</span></code> and <code class="code custom-cpp"><span class="keyword">volatile</span></code> for which <code class="code custom-cpp"><span class="keyword">const_cast</span></code> has to be used) and multiple implementation and platform shenanigans are in play, there are numerous rules that specify different requirements and guarantees. The cast is used practically only for platform-specific code or code that relies on particular implementation guarantees (larger than the standard).</p>
<p>The standard technically allows many obscure platforms, but in practice many (if not majority or all) platforms have relatively simple pointer implementation where:</p>
<ul class="simple">
<li><p><code class="code custom-cpp"><span class="keyword">sizeof</span>(<span class="keyword">void</span>*) == <span class="keyword">sizeof</span>(<span class="param-tmpl">T</span>*)</code> for any <code class="code custom-cpp"><span class="param-tmpl">T</span></code></p></li>
<li><p><code class="code custom-cpp"><span class="keyword">sizeof</span>(<span class="keyword">void</span>*) == <span class="keyword">sizeof</span>(<span class="namespace">std</span>::<span class="type">uintmax_t</span>)</code></p></li>
<li><p><code class="code custom-cpp"><span class="keyword">sizeof</span>(<span class="keyword">void</span>*) == <span class="keyword">sizeof</span>(<span class="namespace">std</span>::<span class="type">uintptr_t</span>)</code></p></li>
<li><p><code class="code custom-cpp"><span class="keyword">alignof</span>(<span class="keyword">void</span>*) == <span class="keyword">alignof</span>(<span class="namespace">std</span>::<span class="type">uintptr_t</span>)</code></p></li>
<li><p><code class="code custom-cpp"><span class="namespace">std</span>::<span class="type">uintmax_t</span></code> and <code class="code custom-cpp"><span class="namespace">std</span>::<span class="type">uintptr_t</span></code> are the same type</p></li>
<li><p><code class="code custom-cpp"><span class="keyword">void</span>*</code> can be safely converted to and from non-member function pointers.</p></li>
</ul>
<p>Note that pointers to member functions are not the same as pointers to free functions as the former have to support <code class="code custom-cpp"><span class="keyword">virtual</span></code> functions and multiple inheritance. Such pointers typically hold multiple addresses and/or offsets. <a class="reference external" href="https://stackoverflow.com/q/12006854/4818802">Relevant SO question.</a></p>
<section id="integral-convertions"><h3>Integral convertions</h3>
<ul class="simple">
<li><p>A pointer can be converted to any integral type large enough to hold all values of its type.</p></li>
<li><p>A value of any integral or enumeration type can be converted to a pointer type. A pointer converted to an integer of sufficient size and back to the same pointer type is guaranteed to have its original value, otherwise the resulting pointer cannot be dereferenced safely (the round-trip conversion in the opposite direction is not guaranteed; the same pointer may have multiple integer representations).</p></li>
</ul>
<p>This is simple. Pointers are just memory addresses (the pointed type is purely an abstraction information for the compiler) so their values can aswell be held by integral types. If implementation supports it, <code class="code custom-cpp"><span class="pp-header">&lt;cstdint&gt;</span></code> delivers <code class="code custom-cpp"><span class="namespace">std</span>::<span class="type">uintptr_t</span></code> (not a separate type but an alias, usually for <code class="code custom-cpp"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span></code>) which is capable of holding pointers to <code class="code custom-cpp"><span class="keyword">void</span></code>. There is also <code class="code custom-cpp"><span class="namespace">std</span>::<span class="type">intptr_t</span></code> but I have never seen anyone using it, <code class="code custom-cpp"><span class="keyword">signed</span></code> integral just doesn't seem right here. I recommend to use <code class="code custom-cpp"><span class="namespace">std</span>::<span class="type">uintptr_t</span></code> if it's available because the name clearly specifies intention.</p>
<!-- This is left unmentioned - seems to have no practical/meritorical value -->
<!-- Any value of type std::nullptr_t, including nullptr can be converted to any integral type as if it were (void*)0, but no value, not even nullptr can be converted to std::nullptr_t: static_cast should be used for that purpose. -->
<ul class="simple">
<li><p>An expression of integral, enumeration, pointer, or pointer-to-member type can be converted to its own type. No changes in value.</p></li>
</ul>
<p>I guess this exists to support templates using <code class="code custom-cpp"><span class="keyword">reinterpret_cast</span></code> which accidentally invoke identity convertions in instantiations for some types.</p>
</section><section id="pointer-convertions"><h3>Pointer convertions</h3>
<ul class="simple">
<li><p>A pointer to member function can be converted to pointer to a different member function of a different type. Conversion back to the original type yields the original value, otherwise the resulting pointer cannot be used safely.</p></li>
<li><p>A pointer to member object of some class <code class="code custom-cpp"><span class="param-tmpl">T</span></code> can be converted to a pointer to another member object of another class <code class="code custom-cpp"><span class="param-tmpl">U</span></code>. If alignment of <code class="code custom-cpp"><span class="param-tmpl">U</span></code> is not stricter than alignment of <code class="code custom-cpp"><span class="param-tmpl">T</span></code> (that is, <code class="code custom-cpp"><span class="keyword">alignof</span>(<span class="param-tmpl">U</span>) &lt;= <span class="keyword">alignof</span>(<span class="param-tmpl">T</span>)</code>), conversion back to the original type <code class="code custom-cpp"><span class="param-tmpl">T</span></code> yields the original value, otherwise the resulting pointer cannot be used safely.</p></li>
<li><p>Any pointer to function can be converted to a pointer to a different function type. Calling the function through a pointer to a different function type is undefined, but converting such pointer back to pointer to the original function type yields the pointer to the original function.</p></li>
<li><p>On some implementations, a function pointer can be converted to <code class="code custom-cpp"><span class="keyword">void</span>*</code> or any other object pointer, or vice versa. If the implementation supports conversion in both directions, conversion to the original type yields the original value, otherwise the resulting pointer cannot be dereferenced or called safely.</p></li>
</ul>
<p>The last point is <a class="reference external" href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/dlsym.html">required on any POSIX compatible system</a> because <code class="code custom-cpp"><span class="func">dlsym</span></code> returns pointers to dynamically loaded objects which may be functions.</p>
</section><section id="aliasing-casts"><h3>Aliasing casts</h3>
<p>These are the primary uses of <code class="code custom-cpp"><span class="keyword">reinterpret_cast</span></code>. They create references/pointers which <em>alias</em> an existing object and allow access to its byte representation.</p>
<aside class="admonition error"><p class="admonition-title">error</p>
<p><code class="code custom-cpp"><span class="keyword">reinterpret_cast</span></code> alone does not justify violating <em>aliasing rules</em>. Only certain types are allowed to <em>alias</em> each other. Any technique that is seemingly capable of creating a situation where two pointers to different types that are not exempt from <em>strict aliasing</em> could simultaneously exist (and both can be used to load or store the same memory) necessarily invokes undefined behavior.</p>
<p>For an explanation about <em>strict aliasing</em> see its dedicated article TOWRITE.</p>
</aside><ul class="simple">
<li><p>Any object pointer type <code class="code custom-cpp"><span class="param-tmpl">T</span>*</code> can be converted to another object pointer type <code class="code custom-cpp"><span class="spec">cv</span> <span class="param-tmpl">U</span>*</code>. This is exactly equivalent to <code class="code custom-cpp"><span class="keyword">static_cast</span>&lt;<span class="spec">cv</span> <span class="param-tmpl">U</span>*&gt;(<span class="keyword">static_cast</span>&lt;<span class="spec">cv</span> <span class="keyword">void</span>*&gt;(<span class="spec">expression</span>))</code>, which implies that if alignment of <code class="code custom-cpp"><span class="param-tmpl">U</span></code> is not stricter than alignment of <code class="code custom-cpp"><span class="param-tmpl">T</span></code> (that is, <code class="code custom-cpp"><span class="keyword">alignof</span>(<span class="param-tmpl">U</span>) &lt;= <span class="keyword">alignof</span>(<span class="param-tmpl">T</span>)</code>), the value of the pointer does not change and conversion of the resulting pointer back to its original type yields the original value.</p></li>
<li><p>An <em>lvalue</em> expression of type <code class="code custom-cpp"><span class="param-tmpl">T</span></code> can be converted to reference to another type <code class="code custom-cpp"><span class="param-tmpl">U</span></code>. The result is an <em>lvalue</em> or <em>xvalue</em> referring to the same object as the original <em>lvalue</em>, but with a different type. No temporary is created, no copy is made, no constructors or conversion functions are called.</p></li>
</ul></section></section><section id="summary"><h2>Summary</h2>
<ul class="simple">
<li>
<p>use <code class="code custom-cpp"><span class="keyword">static_cast</span></code> for:</p>
<ul>
<li><p>converting between different types of data (usually numeric)</p></li>
<li><p>downcasting when it's known that the object if of derived type</p></li>
</ul>
</li>
<li><p>use <code class="code custom-cpp"><span class="keyword">dynamic_cast</span></code> for downcasts and sidecasts when <em>dynamic type</em> of the object is not known</p></li>
<li><p>use <code class="code custom-cpp"><span class="keyword">const_cast</span></code> for dealing for non-cv-qualifier-correct interfaces</p></li>
<li>
<p>use <code class="code custom-cpp"><span class="keyword">reinterpret_cast</span></code> for:</p>
<ul>
<li><p>inspecting object representation</p></li>
<li><p>interacting with low-level facilities</p></li>
<li><p>pointer-integer convertions</p></li>
</ul>
</li>
</ul></section>
</div>
 		<footer class="footer"><div class="footer-item footer-item-container">
				<div class="footer-flex-item">
					<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">
						<img alt="Creative Commons License" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a>
					<br>
					All non-code content licensed under <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, unless stated otherwise.
				</div>
				<div class="footer-flex-item">
					All code content (monospaced font) licensed under <a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/">Creative Commons Zero License</a>, unless stated otherwise.
				</div>
			</div>
			<div class="footer-item footer-item-container">
				<div class="footer-flex-item">
					Generated using heavily customized <a href="https://getnikola.com">Nikola</a> static site generator.
				</div>
				<div class="footer-flex-item">
					<a href="https://github.com/Xeverous/the_website">website repository and issue tracker</a>
				</div>
			</div>
		</footer>
</div>
	</div>
</body>
</html>
