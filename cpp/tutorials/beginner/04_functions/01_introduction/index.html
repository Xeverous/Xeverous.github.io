<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!-- Enable responsiveness on mobile devices--><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title>modern C++ by Xeverous - 01 - introduction</title>
<link rel="icon" href="favicon.png">
<!-- RSS --><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../../../atom.xml">
<!-- CSS --><link rel="stylesheet" href="../../../../../assets/css/styles.css">
<!-- JS --><script type="text/javascript" src="../../../../../assets/js/app.js" defer></script><!-- maybe later
	<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']]
    },
    showMathMenu: false,
    menuSettings: {
      zoom: "None",
      collapsible: false,
      autocollapse: false,
      explorer: false
    }
  });
        </script>
	<script type="text/javascript" async
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"
		async></script>
	-->
</head>
<body>
	<div class="layout">
 <nav class="sidebar"><ul>
<li class="sidebar-section">
			<ul>
<li><a href="../../../../../">HOME</a></li>
				<li><a href="../../../../../index">INDEX</a></li>
			</ul>
</li>

			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ tutorials</h4>
				<p class="sidebar-section-description">Learn C++ from begin() to the end() (and beyond) or use knowledge and experience gained in other languages in the accelerated tutorial.</p>

				<ul>
<li><a href="../../">beginner</a></li>
						<li><a href="../../../accelerated/">accelerated</a></li>
						<li><a href="../../../templates/">templates</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ how-to</h4>
				<p class="sidebar-section-description">Common and specific tasks explained.</p>

				<ul>
<li><a href="../../../../stdlib/">standard library components</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ utilities</h4>
				<p class="sidebar-section-description">Various metarials with concentrated information.</p>

				<ul>
<li><a href="../../../../utility/cheatsheets/">C++ cheatsheets</a></li>
						<li><a href="../../../../utility/cpp_faq/">C++ FAQ</a></li>
						<li><a href="../../../../utility/cpp_myths/">C++ myths</a></li>
						<li><a href="../../../../utility/glossary/">glossary</a></li>
						<li><a href="../../../../utility/">(all articles)</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">misc / meta</h4>
				<p class="sidebar-section-description">About this website and its authors.</p>

				<ul>
<li><a href="../../../../../about/">about</a></li>
						<li><a href="../../../../../meta/site_faq/">website FAQ</a></li>
						<li><a href="../../../../../meta/markdown_test/">Markdown test page</a></li>
						<li><a href="../../../../../meta/rest_test/">reStructuredText test page</a></li>
				</ul>
</li>
	</ul></nav><nav class="topbar"><ul class="menu">
<li class="button"><a href="../../../../../">HOME</a></li>
				<li class="button"><a href="../../../../../index">INDEX</a></li>
				<li class="button"><a href="../../../../../faq">FAQ</a></li>
				<li class="button"><a href="../../../../../about">ABOUT</a></li>
				<li class="button menu-button">
					<div class="menu-icon">
						<div class="bar1"></div>
						<div class="bar2"></div>
						<div class="bar3"></div>
					</div>
				</li>
			</ul></nav><div class="main container">
				<nav class="breadcrumb"><ol>
<li><a href="../../../../../index">index</a></li>
						<span>/</span>
							<li><a href="../../../../">C++</a></li>
							<span>/</span>
							<li><a href="../../../">tutorials</a></li>
							<span>/</span>
							<li><a href="../../">beginner</a></li>
							<span>/</span>
							<li><a href="../">04 - functions</a></li>
							<span>/</span>
						<li>01 - introduction</li>
					</ol></nav><div class="content">
				<h1>01 - introduction</h1>				<p>You definitely have encountered the <em>function</em> term before. It's very likely you already have a rough image what a function is.</p>
<p>In mathematics, (very formally) a function is a relation between two sets that associates each element of the first set to exactly one element of the second set.</p>
<p>In programming, a function is a <strong>reusable piece of code</strong> that given certain set of inputs <em>returns</em> (produces) an output (an object).</p>
<p>In simple words, a function is an abstract mechanism that produdes an output based on the input.</p>
<p>In both mathematics and programming:</p>
<ul class="simple">
<li><p>A function always <em>returns</em> a single value. No matter how many inputs a function gets, it always produces a single output.</p></li>
<li><p>A function can <em>return</em> the same value for multiple, different inputs. For example, a square function <em>returns</em> 4 for both 2 and -2.</p></li>
<li>
<p>A function may receive (invalid) inputs for which there is no result (e.g. division by 0):</p>
<ul>
<li><p>In mathematics: argument out of domain, logic error</p></li>
<li><p>In programming: any kind of error or undefined behavior</p></li>
</ul>
</li>
</ul>
<p>In programming:</p>
<ul class="simple">
<li><p>A function can return different value even if given the same input again. For example, a date/time function can return different date/time each time it's <em>called</em> (used).</p></li>
<li><p>A function can have side effects (e.g. logging something to a file on disk), they are never considered to be function's output nonetheless they are desirable.</p></li>
</ul>
<aside class="admonition note"><p class="admonition-title">note</p>
<p>Functions are one of fundamental programming elements. They allow to build complex programs without code duplication and letting to focus on small tasks one at a time (<a class="reference external" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide and conquer</a> paradigm). In practice, almost every function calls other functions forming deep chains of input-output connections and code reuse.</p>
</aside><!--  --><blockquote>
<p>What if I really want to return multiple objects? I can imagine various situations where some computation could produce multiple results.</p>
</blockquote>
<p>Functions by their core definition always return a single object. The trick is that the object can be of any type.</p>
<ul class="simple">
<li><p>In mathematics, a function can return a complex number or a matrix. These can hold multiple numbers.</p></li>
<li><p>In programming, a function can return an object of a <em>user-defined type</em>. Such types can consist of multiple other types and hold many subobjects. Various programming languages offer the functionality to define new types in the code (most often through the <code class="code custom-cpp"><span class="keyword">class</span></code> keyword).</p></li>
</ul>
<section id="syntax"><h2>Syntax</h2>
<p>Vast majority of functions (formally <em>free functions</em>) are defined using the syntax below. Other kinds of functions (<em>lambda expressions</em> and <em>member functions</em>) will be presented later.</p>
<p>In order:</p>
<ul class="simple">
<li><p>return type</p></li>
<li><p>function name</p></li>
<li><p>function parameters</p></li>
<li><p>function body</p></li>
</ul>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="pp-hash">#</span><span class="pp-directive">include</span> <span class="pp-header">&lt;iostream&gt;</span>
<span class="pp-hash">#</span><span class="pp-directive">include</span> <span class="pp-header">&lt;cmath&gt;</span>

<span class="com-single">// return type: double</span>
<span class="com-single">// name: square</span>
<span class="com-single">// parameters (1): double</span>
<span class="keyword">double</span> <span class="func">square</span>(<span class="keyword">double</span> <span class="param">x</span>)
{
	<span class="keyword">return</span> <span class="var-local">x</span> * <span class="var-local">x</span>;
}

<span class="com-single">// return type: long double</span>
<span class="com-single">// name: herons_formula</span>
<span class="com-single">// parameters (3): all of type long double</span>
<span class="keyword">long</span> <span class="keyword">double</span> <span class="func">herons_formula</span>(<span class="keyword">long</span> <span class="keyword">double</span> <span class="param">a</span>, <span class="keyword">long</span> <span class="keyword">double</span> <span class="param">b</span>, <span class="keyword">long</span> <span class="keyword">double</span> <span class="param">c</span>)
{
	<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> <span class="var-local">s</span> = (<span class="param">a</span> + <span class="param">b</span> + <span class="param">c</span>) / <span class="num">2.0</span>;
	<span class="com-single">// &lt;cmath&gt; provides common mathematical functions, including square root</span>
	<span class="keyword">return</span> <span class="namespace">std</span>::<span class="func">sqrt</span>(<span class="var-local">s</span> * (<span class="var-local">s</span> - <span class="param">a</span>) * (<span class="var-local">s</span> - <span class="param">b</span>) * (<span class="var-local">s</span> - <span class="param">c</span>));
}

<span class="com-single">// return type: int</span>
<span class="com-single">// name: main</span>
<span class="com-single">// parameters (0)</span>
<span class="keyword">int</span> <span class="func">main</span>()
{
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="func">square</span>(<span class="num">2.5</span>) <span class="oo">&lt;&lt;</span> <span class="lit-str">"<span class="esc-seq">\n</span>"</span>;
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="func">square</span>(-<span class="num">2.5</span>) <span class="oo">&lt;&lt;</span> <span class="lit-str">"<span class="esc-seq">\n</span>"</span>;
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="func">herons_formula</span>(<span class="lit-num">4</span>, <span class="lit-num">13</span>, <span class="lit-num">15</span>) <span class="oo">&lt;&lt;</span> <span class="lit-str">"<span class="esc-seq">\n</span>"</span>;
}
</pre></td>
</tr></tbody></table>
<aside class="admonition note"><p class="admonition-title">note</p>
<p>Unlike conditional statements and loops, a function body must always contain <code class="docutils literal">{}</code>.</p>
</aside><aside class="admonition note"><p class="admonition-title">note</p>
<p>Functions are called (used) by providing arguments between <code class="docutils literal">()</code>.</p>
</aside><p>Functions create own scope for their local objects (objects defined inside functions), these objects are destroyed when the function returns - only <em>returned</em> value is retained. If the caller does not use the result (e.g. <code class="code custom-cpp"><span class="func">f</span>(<span class="var-local">x</span>);</code> instead of <code class="code custom-cpp"><span class="var-local">y</span> = <span class="func">f</span>(<span class="var-local">x</span>);</code>) function still works the same but the returned data is lost.</p>
<p>There is no relation between names of function parameters and names of objects that are passed to the function. The compiler only cares whether types match. Names are only an abstraction for the programmer so that it's possible to express what should be done inside the function. Function call expressions are a way to connect separate parts of code.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="pp-hash">#</span><span class="pp-directive">include</span> <span class="pp-header">&lt;iostream&gt;</span>

<span class="keyword">int</span> <span class="func">add</span>(<span class="keyword">int</span> <span class="param">x</span>, <span class="keyword">int</span> <span class="param">y</span>)
{
	<span class="keyword">return</span> <span class="param">x</span> + <span class="param">y</span>;
}

<span class="keyword">int</span> <span class="func">multiply</span>(<span class="keyword">int</span> <span class="param">x</span>, <span class="keyword">int</span> <span class="param">y</span>)
{
	<span class="keyword">return</span> <span class="param">x</span> * <span class="param">y</span>;
}

<span class="keyword">int</span> <span class="func">passthrough</span>(<span class="keyword">int</span> <span class="param">x</span>)
{
	<span class="keyword">return</span> <span class="param">x</span>;
}

<span class="keyword">int</span> <span class="func">main</span>()
{
	<span class="com-single">// some stupid examples to demonstrate nested calls</span>
	<span class="com-single">// output of one function call is the input to another call</span>
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="func">add</span>(<span class="lit-num">1</span>, <span class="func">multiply</span>(<span class="func">add</span>(-<span class="lit-num">4</span>, <span class="lit-num">7</span>), <span class="lit-num">2</span>)) <span class="oo">&lt;&lt;</span> <span class="lit-str">"<span class="esc-seq">\n</span>"</span>;
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="func">passthrough</span>(<span class="func">passthrough</span>(<span class="func">passthrough</span>(<span class="func">passthrough</span>(<span class="lit-num">1</span>)))) <span class="oo">&lt;&lt;</span> <span class="lit-str">"<span class="esc-seq">\n</span>"</span>;

	<span class="com-single">// names do not matter, only types</span>
	<span class="com-single">// here variables are called a and b, and by their position within ()</span>
	<span class="com-single">// they match function parameters x and y</span>
	<span class="keyword">int</span> <span class="var-local">a</span> = <span class="lit-num">2</span>;
	<span class="keyword">int</span> <span class="var-local">b</span> = <span class="lit-num">3</span>;
	<span class="func">add</span>(<span class="var-local">a</span>, <span class="var-local">b</span>); <span class="com-single">// result discarded (will not be printed)</span>
}
</pre></td>
</tr></tbody></table>
<p>If types do not match one of 2 things will happen:</p>
<ul class="simple">
<li><p>values will be <em>converted</em> to match what function expects</p></li>
<li><p>compiler error - the program is <em>ill-formed</em></p></li>
</ul>
<!-- TODO when convertion? --></section><section id="returning"><h2>Returning</h2>
<p>Returning is the act of providing function's result. The type of the object at the <code class="code custom-cpp"><span class="keyword">return</span></code> statement should be the same as function return type (or be implicitly convertible to it). There are no restrictions on the statement itself: there can be multiple of them, there can be code after/before it. Once one <code class="code custom-cpp"><span class="keyword">return</span></code> is reached, the function stops immediately and the control flow comes back to the place from which the function was called.</p>
<aside class="admonition definition"><p class="admonition-title">definition</p>
<p>A function should never reach the end of its body without <code class="code custom-cpp"><span class="keyword">return</span></code> statement.</p>
</aside><p>The function below does not return on all control flow paths. If at runtime this function is called with <code class="code custom-cpp"><span class="lit-num">0</span></code>, it will cause <em>undefined behavior</em>.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">int</span> <span class="func">missing_return</span>(<span class="keyword">int</span> <span class="param">x</span>)
{
	<span class="keyword">if</span> (<span class="param">x</span> &lt; <span class="lit-num">0</span>)
		<span class="keyword">return</span> <span class="param">x</span> * <span class="param">x</span>;
	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="param">x</span> &gt; <span class="lit-num">0</span>)
		<span class="keyword">return</span> <span class="lit-num">2</span> * <span class="param">x</span>;
}
</pre></td>
</tr></tbody></table>
<pre class="code ansi"><span class="ansi1">main.cpp:</span> In function ‘<span class="ansi1">int missing_return(int)</span>’:
<span class="ansi1">main.cpp:7:1:</span> <span class="ansi1 ansi35">warning: </span>control reaches end of non-void function [<span class="ansi1 ansi35">-Wreturn-type</span>]
 <span class="ansi1 ansi35">}</span>
 <span class="ansi1 ansi35">^</span>
</pre>
<!--  -->
<blockquote>
<p>Why such functions are allowed then? Can't the compiler check that a function can finish without returning?</p>
</blockquote>
<p>The compiler can not analyze all possible operations and simulate all potential function usages - there are simply too many of them and many of them may be impossible or simply never happen. For these reasons, in the past it was generally accepted that a function may have hypothetical control flow path that results in reaching end of its body without hitting any return statement. Over time, it turned out that such approach is generally unsafe (bug prone) and results in code that is hard to read and reason about.</p>
<p>The current approach is very simple: <strong>a function should cover all of its control flow paths (even if they seem to never be possible)</strong>. The compiler can not simulate the function, so <strong>it simply checks whether all branches of any conditional instructions end in return statements</strong>. For backwards compatibility, C and C++ still allow functions with missing return statements, but compilers issue a warning. You should treat this warning very seriously.</p>
<p>Remember that the main function has an exception: if control flow reaches its end, it's assumed to be <code class="code custom-cpp"><span class="keyword">return</span> <span class="lit-num">0</span>;</code>.</p>
</section><section id="void-functions"><h2>Void functions</h2>
<p>Functions can have return type specified as <code class="code custom-cpp"><span class="keyword">void</span></code> which means they return no data. This is very useful if the function is used only for its side effects:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">void</span> <span class="func">greet</span>()
{
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">"hello, world<span class="esc-seq">\n</span>"</span>;
}
</pre></td>
</tr></tbody></table>
<p>Such functions do not need to use <code class="code custom-cpp"><span class="keyword">return</span></code> as there is no data to send back to the caller. If you want to exit such function prematurely (that is, stop executing further code under specific condition), you can write <code class="code custom-cpp"><span class="keyword">return</span>;</code> to exit early.</p>
</section><section id="function-size"><h2>Function size</h2>
<p>There have been many guidelines on what's a good size for a function. 20, 50 and even 100 lines of code. <strong>The core principle is that a function should perform exactly 1 task.</strong> If you see an opportunity to split the task into smaller ones, do it even if the function is used only once. Such code is easier to read and test. Functions should be like Lego bricks - they should very easily compose into larger constructions and be easy to modify.</p>
<p>The same principle applies to the amount of function parameters. The more parameters a function has, the harder it's to understand and (due to more complex implementation) the more likely it has bugs and more likely the function can be refactored into multiple smaller ones. There is no hard recommendation on the number of parameters - it's very subjective and depends heavily on the task but for comparison - majority of functions in the C++ standard library take 4 parameters or less.</p>
<p>There is no lower limit on size and arguments. Many useful functions can be as simple as 1 line:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="com-single">// functions that convert between degrees and radians (360 degrees == 2π radians)</span>
<span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="var-global">pi</span> = <span class="num">3.141592653589793</span>;

<span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="func">deg_to_rad</span>(<span class="keyword">double</span> <span class="param">degrees</span>)
{
	<span class="keyword">return</span> <span class="param">degrees</span> * <span class="var-global">pi</span> / <span class="num">180.0</span>;
}

<span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="func">rad_to_deg</span>(<span class="keyword">double</span> <span class="param">radians</span>)
{
	<span class="keyword">return</span> <span class="param">radians</span> * <span class="num">180.0</span> / <span class="var-global">pi</span>;
}
</pre></td>
</tr></tbody></table>
<!-- TODO constexpr functions when? --></section><section id="terminology"><h2>Terminology</h2>
<p>A common mistake is to assume that function <em>arguments</em> means the same as function <em>parameters</em>.</p>
<ul class="simple">
<li><p>Function parameters are what the function definition expects to be passed in (seen from inside the function).</p></li>
<li><p>Function arguments are objects that are given for specific function call (seen from outside of the function).</p></li>
</ul>
<p>Since both must match in order to work, these terms usually mean the same thing. But if they don't, an example compiler error could mention that a specific <em>argument</em> does not match a type of a specific <em>parameter</em>.</p>
</section><section id="implementation"><h2>Implementation</h2>
<p>Conditional statements and loops are jumps ahead/behind in machine code. Because compiled functions are separate blocks of reusable machine code, there must be 2 jumps for each function: one in (the call instruction: jump to function code), one out (the return instruction: jump back to place from where the function was called). Because the same function can be called from different places there is a need to save position in machine code where the execution should continue when the function returns.</p>
<p>In the example below, the first function is called from 2 other functions. You should be able to determine what will be the program's output. If not - compile, run and analyze the output. You should be able to build a mental image (a graph) how function calls interact.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="pp-hash">#</span><span class="pp-directive">include</span> <span class="pp-header">&lt;iostream&gt;</span>

<span class="keyword">void</span> <span class="func">foo</span>()
{
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">"foo<span class="esc-seq">\n</span>"</span>;
}

<span class="keyword">void</span> <span class="func">bar</span>()
{
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">"bar start<span class="esc-seq">\n</span>"</span>;
	<span class="func">foo</span>();
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">"bar finish<span class="esc-seq">\n</span>"</span>;
}

<span class="keyword">void</span> <span class="func">baz</span>()
{
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">"baz start<span class="esc-seq">\n</span>"</span>;
	<span class="func">foo</span>();
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">"baz finish<span class="esc-seq">\n</span>"</span>;
}

<span class="keyword">void</span> <span class="func">func</span>()
{
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">"1<span class="esc-seq">\n</span>"</span>;
	<span class="func">bar</span>();
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">"2<span class="esc-seq">\n</span>"</span>;
	<span class="func">baz</span>();
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">"3<span class="esc-seq">\n</span>"</span>;
}

<span class="keyword">int</span> <span class="func">main</span>()
{
	<span class="func">func</span>();
}
</pre></td>
</tr></tbody></table>
<div class="docutils container">
<details><summary>output</summary><div class="docutils container">
<div class="code"><pre class="code text"><a id="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-1" name="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-1" href="#rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-1"></a>1
<a id="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-2" name="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-2" href="#rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-2"></a>bar start
<a id="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-3" name="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-3" href="#rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-3"></a>foo
<a id="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-4" name="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-4" href="#rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-4"></a>bar finish
<a id="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-5" name="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-5" href="#rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-5"></a>2
<a id="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-6" name="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-6" href="#rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-6"></a>baz start
<a id="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-7" name="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-7" href="#rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-7"></a>foo
<a id="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-8" name="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-8" href="#rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-8"></a>baz finish
<a id="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-9" name="rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-9" href="#rest_code_bf127ccab95147c4a3a6aeb01f8cfda1-9"></a>3
</pre></div>
</div>
</details>
</div>
</section><section id="the-call-stack"><h2>The call stack</h2>
<p>When a function is called, the place where it should return is pushed onto the <em>stack</em>. This data is also accompanied by function arguments (unless the compiler decided to pass them through registers). Stack is a special memory region where function-local data is stored. Simplified diagram:</p>
<img alt="program call stack" src="https://upload.wikimedia.org/wikipedia/commons/8/8a/ProgramCallStack2_en.png"><p><em>Active frame</em> is the range of stack memory that holds information relevant to the function currently being executed. It contains return address (previous value of <em>stack pointer</em>) and any local data (arguments and objects defined inside the function). When this function returns, it will pop current frame (remove it from the stack), return to frame N-1 and change <em>stack pointer</em>.</p>
<img alt="program call stack after return" src="https://upload.wikimedia.org/wikipedia/en/6/60/ProgramCallStack1.png"><p>The mechanism can now repeat: the current function can call another function (which would push new frame with return address equal to current <em>stack pointer</em>) or return (which would pop current frame and revert <em>stack pointer</em>). As the program is executed and functions are called and return, the stack goes up and down constantly reusing stack space.</p>
<p>The stack operates in LIFO manner (last in, first out) - latest frames put on top are also the first frames to be removed. That is, the most recently called function will be the first function to return.</p>
<p>The main function would be the closest one to the stack origin (the bottom), since this is the first function to be called within a program. This also means that the main function is the last function to return.</p>
<blockquote>
<p>Why is the stack upside down? Shouldn't the origin be at memory address 0?</p>
</blockquote>
<p>It could be, but that's how some (if not most) systems implement the stack. The stack memory moves downward from the end and the <em>heap memory</em> moves upward from the beginning. The memory in the middle can become whatever is needed. RAM has no predefined structure, it's up to the operating system to decide how it's used.</p>
<section id="call-stack-in-tools"><h3>Call stack in tools</h3>
<p>Various programming tools (especially debuggers) work in terms of inspecting <em>function call stack</em>. Below is an example of a possible call stack printed by <a class="reference external" href="https://en.wikipedia.org/wiki/AddressSanitizer">AddressSanitizer/LeakSanitizer</a> when it detects a <em>memory leak</em> bug:</p>
<div class="code"><pre class="code text"><a id="rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-1" name="rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-1" href="#rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-1"></a>==26475==ERROR: LeakSanitizer: detected memory leaks
<a id="rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-2" name="rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-2" href="#rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-2"></a>
<a id="rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-3" name="rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-3" href="#rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-3"></a>Direct leak of 5 byte(s) in 1 object(s) allocated from:
<a id="rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-4" name="rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-4" href="#rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-4"></a>    #0 0x44f2de in malloc /usr/home/hacker/llvm/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:74
<a id="rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-5" name="rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-5" href="#rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-5"></a>    #1 0x464e86 in baz (/usr/home/hacker/a.out+0x464e86)
<a id="rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-6" name="rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-6" href="#rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-6"></a>    #2 0x464fb4 in main (/usr/home/hacker/a.out+0x464fb4)
<a id="rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-7" name="rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-7" href="#rest_code_97ec91fbf1bc45f0ab0775a7ed05cb78-7"></a>    #3 0x7f7e760b476c in __libc_start_main /build/buildd/eglibc-2.15/csu/libc-start.c:226
</pre></div>
<aside class="admonition note"><p class="admonition-title">note</p>
<p>Main function may not be actually first due to implementation-specific reasons. Many platforms require extra work to be done before actual code can run. In most situations (without sanitizers) on GNU/Linux systems the first function is named <code class="docutils literal">_start</code> but other magic names (starting with <code class="docutils literal">_</code>) can appear too.</p>
</aside><p>The call stack alone is often enough to identify the problem. Through this information alone, you know which function called which and through that you can reason about control flow paths that the program has gone through. The source of a bug is usually found just before first unexpected function call.</p>
</section><section id="stack-overflow"><h3>Stack overflow</h3>
<aside class="admonition definition"><p class="admonition-title">definition</p>
<p>A situation when stack memory is exhausted and an attempt is made to occupy even more is <strong>stack overflow</strong>. This has undefined behavior.</p>
</aside><p>On GNU/Linux systems, Bash shell has a built-in command that can be used to check various resource limits, including stack memory. Example done on a 64-bit PC:</p>
<div class="code"><pre class="code text"><a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-1" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-1" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-1"></a>$ ulimit -a
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-2" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-2" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-2"></a>core file size          (blocks, -c) 0
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-3" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-3" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-3"></a>data seg size           (kbytes, -d) unlimited
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-4" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-4" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-4"></a>scheduling priority             (-e) 0
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-5" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-5" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-5"></a>file size               (blocks, -f) unlimited
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-6" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-6" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-6"></a>pending signals                 (-i) 15450
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-7" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-7" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-7"></a>max locked memory       (kbytes, -l) 65536
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-8" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-8" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-8"></a>max memory size         (kbytes, -m) unlimited
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-9" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-9" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-9"></a>open files                      (-n) 1024
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-10" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-10" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-10"></a>pipe size            (512 bytes, -p) 8
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-11" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-11" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-11"></a>POSIX message queues     (bytes, -q) 819200
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-12" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-12" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-12"></a>real-time priority              (-r) 0
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-13" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-13" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-13"></a>stack size              (kbytes, -s) 8192
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-14" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-14" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-14"></a>cpu time               (seconds, -t) unlimited
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-15" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-15" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-15"></a>max user processes              (-u) 15450
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-16" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-16" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-16"></a>virtual memory          (kbytes, -v) unlimited
<a id="rest_code_6a568f16ef4f4c77b39c50c5e901587f-17" name="rest_code_6a568f16ef4f4c77b39c50c5e901587f-17" href="#rest_code_6a568f16ef4f4c77b39c50c5e901587f-17"></a>file locks                      (-x) unlimited
</pre></div>
<p>8 MiB doesn't seem to be much but in reality, unless forced on purpose, stack overflow is hard to achieve. Most complex programs I have seen nest few hundred function calls. Stack pointer is the same size as the architecture (8 bytes on 64-bit CPU), adding this to other control data and average few function parameters and average few local variables we get a guesstimate of 64-128 bytes of stack data per function. Assuming few hundred nested function calls, we get at most few hundred kilobytes. That's far less than 8 MiB.</p>
<blockquote>
<p>How then can programs process gigabytes (or even more) of data?</p>
</blockquote>
<p>So far everything done in the tutorial was using <em>local variables</em> with <em>automatic storage</em> which use <em>stack memory</em>. Any large data is pretty much always allocated dynamically, using <em>heap memory</em>. Functions can work on this data but the data itself is allocated separately. This is related to indirect mechanisms (e.g. arrays, references, pointers) where a single variable (allocated on the stack) can refer to a huge block of memory (allocated on the heap). This single variable can then be used to refer to an arbitrary amount of objects. For performance reasons "the heavy data" is kept separately from functions. Such data very often needs to be stored for long periods of time (across multiple functions) so constantly moving it in the stack memory would be very wasteful and time-consuming.</p>
<blockquote>
<p>How is stack and heap memory related to RAM?</p>
</blockquote>
<p>Both are a part of RAM, where stack memory is a small selected region. The selection (for each program and for itself) is made by the operating system. RAM itself is only a one huge array of memory cells with nothing predefined. It's up to the software (especially OS) to form some structure and give meaning to specific ranges of memory cells.</p>
<p>Processors contain SRAM (static RAM) which is a much faster memory than main RAM (dynamic RAM or DRAM). SRAM is typically used for the cache and internal registers of a CPU. Cache is closely related to currently executed function and its data so very often it will contain copies of the stack memory. From programming point of view, these mechanisms are invisible - it's just an optimization hidden in the hardware, code is generally written without caring about it.</p>
</section></section><section id="common-mistakes"><h2>Common mistakes</h2>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="pp-hash">#</span><span class="pp-directive">include</span> <span class="pp-header">&lt;iostream&gt;</span>

<span class="keyword">void</span> <span class="func">greet</span>()
{
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">"hello, world"</span>;
}

<span class="keyword">int</span> <span class="func">get_std_year</span>()
{
	<span class="com-single">// macro is a number in the form YYYYMM</span>
	<span class="keyword">return</span> <span class="macro">__cplusplus</span> / <span class="lit-num">100</span>;
}

<span class="keyword">int</span> <span class="func">main</span>()
{
	<span class="com-single">// feeding std::cout with "data of type void"</span>
	<span class="com-single">// the function should either be called directly or return the string</span>
	<span class="com-single">// this will not compile and likely print many overloads of operator&lt;&lt;</span>
	<span class="com-single">// and explain for each overload why it does not match (pretty long list)</span>
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="problem">&lt;&lt;</span> <span class="func">greet</span>();

	<span class="com-single">// attempting to call a function with no actual call - missing ()</span>
	<span class="com-single">// this expression is valid (it will just evaluate function address)</span>
	<span class="com-single">// may print a warning that this statement has no effect</span>
	<span class="func">greet</span>;

	<span class="com-single">// as above, now just printing address of the function</span>
	<span class="com-single">// this will compile and print some non-zero value</span>
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="func">get_std_year</span>;
}
</pre></td>
</tr></tbody></table></section><section id="recommendations"><h2>Recommendations</h2>
<ul class="simple">
<li><p>Unless there is a better reason, function parameters should be ordered in decreasing importance (most important parameters first). This approach is especially useful for functions with <em>default parameters</em> (described later in this chapter).</p></li>
<li><p>Variables are data. Functions are tasks. Variables should be named as nouns and functions as verbs. Don't be afraid of using long, multi-word names. Examples here use <code class="docutils literal">x</code>, <code class="docutils literal">y</code>, <code class="docutils literal">z</code> etc. only because the context is very generic and math typically uses single letters.</p></li>
<li><p>Before you write a function for some task, check whether it's not already in the standard library. A lot of common mathematical operations are already available in <a class="reference external" href="https://en.cppreference.com/w/cpp/header/cmath">cmath header</a>.</p></li>
</ul></section><section id="exercise"><h2>Exercise</h2>
<ul class="simple">
<li><p>Compile the function with missing return statement and observe any compiler warnings. Don't try calling it - you should never expect anything meaningful from undefined behavior.</p></li>
<li><p>Compile code with common mistakes to observe potential compiler errors.</p></li>
<li><p>Remember Collatz conjecture from the control flow chapter? Now write a function that given a number, returns the next number. Modify the program from that lesson to use this function.</p></li>
</ul>
<div class="docutils container">
<details><summary>Collatz function solution</summary><div class="docutils container">
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">long</span> <span class="keyword">long</span> <span class="func">collatz_next_number</span>(<span class="keyword">long</span> <span class="keyword">long</span> <span class="param">n</span>)
{
	<span class="keyword">if</span> (<span class="param">n</span> % <span class="lit-num">2</span> == <span class="lit-num">0</span>)
		<span class="keyword">return</span> <span class="param">n</span> / <span class="lit-num">2</span>;
	<span class="keyword">else</span>
		<span class="keyword">return</span> <span class="lit-num">3</span> * <span class="param">n</span> + <span class="lit-num">1</span>;
}
</pre></td>
</tr></tbody></table>
</div>
</details>
</div>
</section>
</div>
 		<footer class="footer"><div class="footer-item footer-item-container">
				<div class="footer-flex-item">
					<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">
						<img alt="Creative Commons License" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a>
					<br>
					All non-code content licensed under <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, unless stated otherwise.
				</div>
				<div class="footer-flex-item">
					All code content (monospaced font) licensed under <a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/">Creative Commons Zero License</a>, unless stated otherwise.
				</div>
			</div>
			<div class="footer-item footer-item-container">
				<div class="footer-flex-item">
					Generated using heavily customized <a href="https://getnikola.com">Nikola</a> static site generator.
				</div>
				<div class="footer-flex-item">
					<a href="https://github.com/Xeverous/the_website">website repository and issue tracker</a>
				</div>
			</div>
		</footer>
</div>
	</div>
</body>
</html>
