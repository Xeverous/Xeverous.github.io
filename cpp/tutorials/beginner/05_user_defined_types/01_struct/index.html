<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!-- Enable responsiveness on mobile devices--><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title>modern C++ by Xeverous - 01 - struct</title>
<link rel="icon" href="favicon.png">
<!-- RSS --><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../../../atom.xml">
<!-- CSS --><link rel="stylesheet" href="../../../../../assets/css/styles.css">
<!-- JS --><script type="text/javascript" src="../../../../../assets/js/app.js" defer></script><!-- maybe later
	<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']]
    },
    showMathMenu: false,
    menuSettings: {
      zoom: "None",
      collapsible: false,
      autocollapse: false,
      explorer: false
    }
  });
        </script>
	<script type="text/javascript" async
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"
		async></script>
	-->
</head>
<body>
	<div class="layout">
 <nav class="sidebar"><ul>
<li class="sidebar-section">
			<ul>
<li><a href="../../../../../">HOME</a></li>
				<li><a href="../../../../../index/">INDEX</a></li>
			</ul>
</li>

			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ tutorials</h4>
				<p class="sidebar-section-description">Learn C++ from begin() to the end() (and beyond) or use knowledge and experience gained in other languages in the accelerated tutorial.</p>

				<ul>
<li><a href="../../">beginner</a></li>
						<li><a href="../../../accelerated/">accelerated</a></li>
						<li><a href="../../../templates/">templates</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ how-to</h4>
				<p class="sidebar-section-description">Common and specific tasks explained.</p>

				<ul>
<li><a href="../../../../stdlib/">standard library components</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ utilities</h4>
				<p class="sidebar-section-description">Various metarials with concentrated information.</p>

				<ul>
<li><a href="../../../../utility/cheatsheets/">C++ cheatsheets</a></li>
						<li><a href="../../../../utility/cpp_faq/">C++ FAQ</a></li>
						<li><a href="../../../../utility/cpp_myths/">C++ myths</a></li>
						<li><a href="../../../../utility/glossary/">glossary</a></li>
						<li><a href="../../../../utility/">(all articles)</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">misc / meta</h4>
				<p class="sidebar-section-description">About this website and its authors.</p>

				<ul>
<li><a href="../../../../../about/">about</a></li>
						<li><a href="../../../../../meta/site_faq/">website FAQ</a></li>
						<li><a href="../../../../../meta/markdown_test/">Markdown test page</a></li>
						<li><a href="../../../../../meta/rest_test/">reStructuredText test page</a></li>
				</ul>
</li>
	</ul></nav><nav class="topbar"><ul class="menu">
<li class="button"><a href="../../../../../">HOME</a></li>
				<li class="button"><a href="../../../../../index/">INDEX</a></li>
				<li class="button"><a href="../../../../../faq/">FAQ</a></li>
				<li class="button"><a href="../../../../../about/">ABOUT</a></li>
				<li class="button menu-button">
					<div class="menu-icon">
						<div class="bar1"></div>
						<div class="bar2"></div>
						<div class="bar3"></div>
					</div>
				</li>
			</ul></nav><div class="main container">
				<nav class="breadcrumb"><ol>
<li><a href="../../../../../index/">index</a></li>
						<span>/</span>
							<li><a href="../../../../">C++</a></li>
							<span>/</span>
							<li><a href="../../../">tutorials</a></li>
							<span>/</span>
							<li><a href="../../">beginner</a></li>
							<span>/</span>
							<li><a href="../">05 - user defined types</a></li>
							<span>/</span>
						<li>01 - struct</li>
					</ol></nav><div class="content">
				<h1>01 - struct</h1>				<p>It's quite common to have a few closely related variables. The <code class="code custom-cpp"><span class="keyword">struct</span></code> keyword allows you to define a new type that consists of multiple objects.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">struct</span> <span class="type">point</span> <span class="com-single">// the name of the type</span>
{
	<span class="com-single">// members</span>
	<span class="keyword">int</span> <span class="var-local">x</span>;
	<span class="keyword">int</span> <span class="var-local">y</span>;
}; <span class="com-single">// don't forget ; when defining types</span>
</pre></td>
</tr></tbody></table>
<p>Entities defined inside are called <em>members</em>. Here the <code class="code custom-cpp"><span class="type">point</span></code> type has 2 <em>data members</em>. Later you will learn about <em>member functions</em> and <em>member types</em>.</p>
<p>This code alone doesn't create any objects - it defines a type. <code class="code custom-cpp"><span class="type">point</span>.<span class="var-member">x</span></code> is not a valid expression. First you need to create an object of this type:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="type">point</span> <span class="var-local">p1</span>; <span class="com-single">// right here x and y are still uninitialized</span>
<span class="com-single">// members are accessed through "."</span>
<span class="var-local">p1</span>.<span class="var-member">x</span> = <span class="lit-num">2</span>;
<span class="var-local">p1</span>.<span class="var-member">y</span> = <span class="lit-num">3</span>;

<span class="com-single">// aggregate initialization</span>
<span class="type">point</span> <span class="var-local">p2</span>{-<span class="lit-num">3</span>, <span class="lit-num">5</span>};

<span class="com-single">// copy initialization</span>
<span class="type">point</span> <span class="var-local">p3</span> = <span class="var-local">p2</span>;

<span class="com-single">// assignment operator (by default applies assignment to each data member)</span>
<span class="var-local">p1</span> = <span class="var-local">p2</span>;
</pre></td>
</tr></tbody></table>
<p>You can specify default values for members. If the object is not explicitly initialized, it will use initializers specified in the type definition.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="pp-hash">#</span><span class="pp-directive">include</span> <span class="pp-header">&lt;iostream&gt;</span>

<span class="keyword">struct</span> <span class="type">point</span>
{
	<span class="keyword">int</span> <span class="var-member">x</span> = <span class="lit-num">0</span>;
	<span class="keyword">int</span> <span class="var-member">y</span> = <span class="lit-num">0</span>;
};

<span class="keyword">int</span> <span class="func">main</span>()
{
	<span class="type">point</span> <span class="var-local">p1</span>;
	<span class="type">point</span> <span class="var-local">p2</span>{<span class="lit-num">2</span>, <span class="lit-num">2</span>};

	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">"p1 = ("</span> <span class="oo">&lt;&lt;</span> <span class="var-local">p1</span>.<span class="var-member">x</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">", "</span> <span class="oo">&lt;&lt;</span> <span class="var-local">p1</span>.<span class="var-member">y</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">")<span class="esc-seq">\n</span>"</span>
	          <span class="oo">&lt;&lt;</span> <span class="lit-str">"p2 = ("</span> <span class="oo">&lt;&lt;</span> <span class="var-local">p2</span>.<span class="var-member">x</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">", "</span> <span class="oo">&lt;&lt;</span> <span class="var-local">p2</span>.<span class="var-member">y</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">")<span class="esc-seq">\n</span>"</span>;
}
</pre></td>
</tr></tbody></table>
<p>If the initializers were not specified in the type definition, reading their values before assignment would be undefined behavior. Thus, <strong>it's recommended to always initialze members</strong>.</p>
<p>The example above contains small code duplication. We can fix it by writing a function:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">void</span> <span class="func">print</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="param">name</span>, <span class="type">point</span> <span class="param">p</span>)
{
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="param">name</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">" = ("</span> <span class="oo">&lt;&lt;</span> <span class="param">p</span>.<span class="var-member">x</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">", "</span> <span class="oo">&lt;&lt;</span> <span class="param">p</span>.<span class="var-member">y</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">")<span class="esc-seq">\n</span>"</span>;
}
</pre></td>
</tr></tbody></table>
<section id="nested-structures"><h2>Nested structures</h2>
<p>It's possible to nest structures. This is known as <strong>composition</strong> and is one of primary ways of reusing code to build larger programs.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="pp-hash">#</span><span class="pp-directive">include</span> <span class="pp-header">&lt;iostream&gt;</span>

<span class="keyword">struct</span> <span class="type">point</span>
{
	<span class="keyword">int</span> <span class="var-member">x</span> = <span class="lit-num">0</span>;
	<span class="keyword">int</span> <span class="var-member">y</span> = <span class="lit-num">0</span>;
};

<span class="keyword">struct</span> <span class="type">triangle</span>
{
	<span class="keyword">point</span> <span class="var-member">p1</span>;
	<span class="keyword">point</span> <span class="var-member">p2</span>;
	<span class="keyword">point</span> <span class="var-member">p3</span>;
};

<span class="keyword">struct</span> <span class="type">circle</span>
{
	<span class="com-single">// initializers already specified inside</span>
	<span class="keyword">point</span> <span class="var-member">origin</span>;
	<span class="com-single">// built-in types need initializers</span>
	<span class="keyword">int</span> <span class="var-member">radius</span> = <span class="lit-num">0</span>;
};

<span class="keyword">void</span> <span class="func">print</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="param">name</span>, <span class="type">point</span> <span class="param">p</span>)
{
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="param">name</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">" = ("</span> <span class="oo">&lt;&lt;</span> <span class="param">p</span>.<span class="var-member">x</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">", "</span> <span class="oo">&lt;&lt;</span> <span class="param">p</span>.<span class="var-member">y</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">")<span class="esc-seq">\n</span>"</span>;
}

<span class="keyword">void</span> <span class="func">print</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="param">name</span>, <span class="type">triangle</span> <span class="param">t</span>)
{
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="param">name</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">" = {<span class="esc-seq">\n</span>"</span>;
	<span class="func">print</span>(<span class="lit-str">"p1"</span>, <span class="param">t</span>.<span class="var-member">p1</span>);
	<span class="func">print</span>(<span class="lit-str">"p2"</span>, <span class="param">t</span>.<span class="var-member">p2</span>);
	<span class="func">print</span>(<span class="lit-str">"p3"</span>, <span class="param">t</span>.<span class="var-member">p3</span>);
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">"}<span class="esc-seq">\n</span>"</span>;
}

<span class="keyword">int</span> <span class="func">main</span>()
{
	<span class="type">triangle</span> <span class="var-local">t1</span>;
	<span class="var-local">t1</span>.<span class="var-member">p1</span>.<span class="var-member">x</span> = <span class="lit-num">1</span>;
	<span class="var-local">t1</span>.<span class="var-member">p1</span>.<span class="var-member">y</span> = <span class="lit-num">2</span>;
	<span class="var-local">t1</span>.<span class="var-member">p2</span>.<span class="var-member">x</span> = -<span class="lit-num">2</span>;
	<span class="var-local">t1</span>.<span class="var-member">p2</span>.<span class="var-member">y</span> = -<span class="lit-num">1</span>;
	<span class="var-local">t1</span>.<span class="var-member">p3</span>.<span class="var-member">x</span> = <span class="lit-num">3</span>;
	<span class="var-local">t1</span>.<span class="var-member">p3</span>.<span class="var-member">y</span> = <span class="lit-num">3</span>;

	<span class="com-single">// equivalent aggregate initialization (C++14)</span>
	<span class="type">triangle</span> <span class="var-local">t2</span>{{<span class="lit-num">1</span>, <span class="lit-num">2</span>}, {-<span class="lit-num">2</span>, -<span class="lit-num">1</span>}, {<span class="lit-num">3</span>, <span class="lit-num">3</span>}};

	<span class="func">print</span>(<span class="lit-str">"t1"</span>, <span class="var-local">t1</span>);
	<span class="func">print</span>(<span class="lit-str">"t2"</span>, <span class="var-local">t2</span>);
}
</pre></td>
</tr></tbody></table>
<aside class="admonition warning"><p class="admonition-title">warning</p>
<p>Definition of <em>aggregates</em> (and thus <em>aggregate initialization</em>) have been evolving across C++11/14/17/20. See <a class="reference external" href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">https://en.cppreference.com/w/cpp/language/aggregate_initialization</a> for exact details.</p>
</aside><p>The code above requires C++14, becase <em>default member initializers</em> introduced in C++11 initially were outside the definition of an <em>aggregate</em>. If you want to make the code above C++11-compatible, you have to remove default member initializers.</p>
<!--  -->
<blockquote>
<p>I don't like the fact that in the second overload of <code class="code custom-cpp"><span class="func">print</span></code> the code mixes function calls with <code class="code custom-cpp"><span class="namespace">std</span>::<span class="var-global">cout</span></code>. Is it possible to make <code class="code custom-cpp"><span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="var-local">p</span></code> work?</p>
</blockquote>
<p>Yes. The specific feature that supports it is known as <em>operator overloading</em>. You can overload operators (they work just like functions with few restrictions) for <em>user-defined types</em> (built-in types already have behavior specified). I'm not going to delve into details as the topic is described in it's own chapter but for the sake of example:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="com-single">// std::cout is a global object of type std::ostream</span>
<span class="namespace">std</span>::<span class="type">ostream</span>&amp; <span class="keyword">operator</span><span class="func">&lt;&lt;</span>(<span class="namespace">std</span>::<span class="type">ostream</span>&amp; <span class="param">stream</span>, <span class="type">point</span> <span class="param">p</span>)
{
	<span class="keyword">return</span> <span class="param">stream</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">"("</span> <span class="oo">&lt;&lt;</span> <span class="param">p</span>.<span class="var-member">x</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">", "</span> <span class="oo">&lt;&lt;</span> <span class="param">p</span>.<span class="var-member">y</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">")<span class="esc-seq">\n</span>"</span>;
}
</pre></td>
</tr></tbody></table></section><section id="more-syntax"><h2>More syntax</h2>
<ul>
<li><p>Unary operators when combined with member access are written like this: <code class="code custom-cpp">++<span class="var-local">t1</span>.<span class="var-member">p3</span>.<span class="var-member">y</span></code> (<code class="docutils literal">.</code> has higher priority).</p></li>
<li>
<p>Type definitions can be combined with object definitions like this:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">struct</span> <span class="com-multi">/* point */</span> <span class="com-single">// in such case name is optional</span>
{
	<span class="keyword">int</span> <span class="var-member">x</span>;
	<span class="keyword">int</span> <span class="var-member">y</span>;
} <span class="var-local">p</span>; <span class="com-single">// defines an object named "p" of an anonymous type</span>
</pre></td>
</tr></tbody></table>
<p>though such code is generally considered to be less readable (and potentially troublesome). Such practice is typically only done for types defined as nested types within other types.</p>
</li>
</ul></section><section id="named-parameters"><h2>Named parameters</h2>
<p>In sitations where a function has multiple parameters of the same type (especially <code class="code custom-cpp"><span class="keyword">bool</span></code>), a structure can be introduced to avoid hardly readable code:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">int</span> <span class="func">start_process</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="param">cmd</span>, <span class="keyword">bool</span> <span class="param">capture_std_err</span> = <span class="keyword">true</span>, <span class="keyword">bool</span> <span class="param">capture_std_out</span> = <span class="keyword">true</span>, <span class="keyword">bool</span> <span class="param">detach</span> = <span class="keyword">false</span>);

<span class="com-single">// ...</span>

<span class="keyword">int</span> <span class="var-local">pid</span> = <span class="func">start_process</span>(<span class="var-local">cmd</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>); <span class="com-single">// hard to read without remembering precise order of parameters</span>
</pre></td>
</tr></tbody></table>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">struct</span> <span class="type">process_options</span>
{
	<span class="keyword">bool</span> <span class="var-member">capture_std_err</span> = <span class="keyword">true</span>;
	<span class="keyword">bool</span> <span class="var-member">capture_std_out</span> = <span class="keyword">true</span>;
	<span class="keyword">bool</span> <span class="var-member">detach</span> = <span class="keyword">false</span>;
};

<span class="keyword">int</span> <span class="func">start_process</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="param">cmd</span>, <span class="type">process_options</span> <span class="param">options</span>);

// ...

<span class="type">process_options</span> <span class="var-local">options</span>;
<span class="var-local">options</span>.<span class="var-member">capture_std_err</span> = <span class="keyword">true</span>;
<span class="var-local">options</span>.<span class="var-member">capture_std_out</span> = <span class="keyword">false</span>;
<span class="var-local">options</span>.<span class="var-member">detach</span> = <span class="keyword">true</span>;
<span class="keyword">int</span> <span class="var-local">pid</span> = <span class="func">start_process</span>(<span class="var-local">cmd</span>, <span class="var-local">options</span>);
</pre></td>
</tr></tbody></table>
<p>An additional benefit is that a <code class="code custom-cpp"><span class="keyword">struct</span></code> can be extended in more ways than function's default arguments.</p>
</section><section id="tag-names-in-c"><h2>Tag names in C</h2>
<p>C requires keywords <code class="code custom-cpp"><span class="keyword">struct</span></code>, <code class="code custom-cpp"><span class="keyword">enum</span></code> and <code class="code custom-cpp"><span class="keyword">union</span></code> to be repeated every time respective type names are used.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="com-single">// C++</span>
<span class="type">point</span> <span class="var-local">p</span>;
<span class="keyword">void</span> <span class="func">print</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="param">name</span>, <span class="type">point</span> <span class="param">p</span>);

<span class="com-single">// C, also valid in C++ for compatibility but ugly</span>
<span class="keyword">struct</span> <span class="type">point</span> <span class="var-local">p</span>;
<span class="keyword">void</span> <span class="func">print</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="param">name</span>, <span class="keyword">struct</span> <span class="type">point</span> <span class="param">p</span>);
</pre></td>
</tr></tbody></table>
<p>C++ offers <code class="code custom-cpp"><span class="keyword">namespace</span></code>s to group related names and avoid name conflicts in large programs - showcased code already contained some names from <code class="code custom-cpp"><span class="keyword">namespace</span> <span class="namespace">std</span></code>.</p>
<p>In C, there are no namespaces. Instead, there are "tag spaces" for names attached to different kinds of definitions. When a name from specific "tag space" is used, it must be preceeded by the tag keyword. Tag names can be introduced into global "name space" through aliases:</p>
<!-- TODO typedef/using when? -->
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">struct</span> <span class="type">point</span> {
	<span class="keyword">int</span> <span class="var-member">x</span>;
	<span class="keyword">int</span> <span class="var-member">y</span>;
};
<span class="com-multi">/* because "tag space" and global "name space" are separate,</span>
   <span class="com-multi">they can use identical identifiers */</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="type">point</span> <span class="type">point</span>;

<span class="com-multi">/* shorter form, without providing tag name */</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> {
	<span class="keyword">int</span> <span class="var-member">x</span>;
	<span class="keyword">int</span> <span class="var-member">y</span>;
} <span class="type">point</span>;
</pre></td>
</tr></tbody></table>
<p>Some C projects use such aliases for all of their types, others explicitly prohibit this practice (most notably the Linux kernel).</p>
<p>Writing <code class="code custom-cpp"><span class="keyword">typedef</span> <span class="keyword">struct</span></code> is considered ugly in C++ because there is no need to do so. Even if the definition comes from C code, there is no need to prepend <code class="code custom-cpp"><span class="keyword">struct</span></code>, <code class="code custom-cpp"><span class="keyword">enum</span></code> and <code class="code custom-cpp"><span class="keyword">union</span></code>.</p>
<p>More information:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c">https://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c</a></p></li>
<li><p><a class="reference external" href="https://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c">https://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c</a></p></li>
</ul></section>
</div>
 		<footer class="footer"><div class="footer-item footer-item-container">
				<div class="footer-flex-item">
					<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">
						<img alt="Creative Commons License" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a>
					<br>
					All non-code content licensed under <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, unless stated otherwise.
				</div>
				<div class="footer-flex-item">
					All code content (monospaced font) licensed under <a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/">Creative Commons Zero License</a>, unless stated otherwise.
				</div>
			</div>
			<div class="footer-item footer-item-container">
				<div class="footer-flex-item">
					Generated using heavily customized <a href="https://getnikola.com">Nikola</a> static site generator.
				</div>
				<div class="footer-flex-item">
					<a href="https://github.com/Xeverous/the_website">website repository and issue tracker</a>
				</div>
			</div>
		</footer>
</div>
	</div>
</body>
</html>
