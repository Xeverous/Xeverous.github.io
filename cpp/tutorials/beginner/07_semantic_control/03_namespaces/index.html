<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!-- Enable responsiveness on mobile devices--><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title>modern C++ by Xeverous - 03 - namespaces</title>
<link rel="icon" href="favicon.png">
<!-- RSS --><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../../../atom.xml">
<!-- CSS --><link rel="stylesheet" href="../../../../../assets/css/styles.css">
<!-- JS --><script type="text/javascript" src="../../../../../assets/js/app.js" defer></script><!-- maybe later
	<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']]
    },
    showMathMenu: false,
    menuSettings: {
      zoom: "None",
      collapsible: false,
      autocollapse: false,
      explorer: false
    }
  });
        </script>
	<script type="text/javascript" async
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"
		async></script>
	-->
</head>
<body>
	<div class="layout">
 <nav class="sidebar"><ul>
<li class="sidebar-section">
			<ul>
<li><a href="../../../../../">HOME</a></li>
				<li><a href="../../../../../index">INDEX</a></li>
			</ul>
</li>

			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ tutorials</h4>
				<p class="sidebar-section-description">Learn C++ from begin() to the end() (and beyond) or use knowledge and experience gained in other languages in the accelerated tutorial.</p>

				<ul>
<li><a href="../../">beginner</a></li>
						<li><a href="../../../accelerated/">accelerated</a></li>
						<li><a href="../../../templates/">templates</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ how-to</h4>
				<p class="sidebar-section-description">Common and specific tasks explained.</p>

				<ul>
<li><a href="../../../../stdlib/">standard library components</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ utilities</h4>
				<p class="sidebar-section-description">Various metarials with concentrated information.</p>

				<ul>
<li><a href="../../../../utility/cheatsheets/">C++ cheatsheets</a></li>
						<li><a href="../../../../utility/cpp_faq/">C++ FAQ</a></li>
						<li><a href="../../../../utility/cpp_myths/">C++ myths</a></li>
						<li><a href="../../../../utility/glossary/">glossary</a></li>
						<li><a href="../../../../utility/">(all articles)</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">misc / meta</h4>
				<p class="sidebar-section-description">About this website and its authors.</p>

				<ul>
<li><a href="../../../../../about/">about</a></li>
						<li><a href="../../../../../meta/site_faq/">website FAQ</a></li>
						<li><a href="../../../../../meta/markdown_test/">Markdown test page</a></li>
						<li><a href="../../../../../meta/rest_test/">reStructuredText test page</a></li>
				</ul>
</li>
	</ul></nav><nav class="topbar"><ul class="menu">
<li class="button"><a href="../../../../../">HOME</a></li>
				<li class="button"><a href="../../../../../index">INDEX</a></li>
				<li class="button"><a href="../../../../../faq">FAQ</a></li>
				<li class="button"><a href="../../../../../about">ABOUT</a></li>
				<li class="button menu-button">
					<div class="menu-icon">
						<div class="bar1"></div>
						<div class="bar2"></div>
						<div class="bar3"></div>
					</div>
				</li>
			</ul></nav><div class="main container">
				<nav class="breadcrumb"><ol>
<li><a href="../../../../../index">index</a></li>
						<span>/</span>
							<li><a href="../../../../">C++</a></li>
							<span>/</span>
							<li><a href="../../../">tutorials</a></li>
							<span>/</span>
							<li><a href="../../">beginner</a></li>
							<span>/</span>
							<li><a href="../">07 - semantic control</a></li>
							<span>/</span>
						<li>03 - namespaces</li>
					</ol></nav><div class="content">
				<h1>03 - namespaces</h1>				<!-- some notes about order of sections in this lesson: -->
<!-- - anonymous namespaces are after using-directive because they work similarly (as if the namespace had unique name and followed by using namespace) -->
<!-- - inline namespace are are after using-directive because they have special interaction with them (finely-grained usings) -->
<p>Namespaces are C++ equivalent of filesystem directories. They group entities under same name prefix, but <code class="docutils literal">::</code> is used instead of <code class="docutils literal">/</code>.</p>
<p>The primary purpose of namespaces is grouping related entities and preventing name conflicts. C++ standard library uses <code class="code custom-cpp"><span class="keyword">namespace</span> <span class="namespace">std</span></code> but there are some inner namespaces too, e.g. <code class="code custom-cpp"><span class="namespace">std</span>::<span class="namespace">chrono</span></code>.</p>
<section id="syntax"><h2>Syntax</h2>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">namespace</span> <span class="namespace">foo</span> { <span class="keyword">void</span> <span class="func">f1</span>(); }

<span class="com-single">// namespaces can be opened multiple times, potentially in different files</span>
<span class="keyword">namespace</span> <span class="namespace">foo</span> { <span class="keyword">void</span> <span class="func">f2</span>(); }

<span class="com-single">// namespaces can be nested and entities can appear at any level</span>
<span class="keyword">namespace</span> <span class="namespace">bar</span> {
	<span class="keyword">void</span> <span class="func">f3</span>();

	<span class="keyword">namespace</span> <span class="namespace">foo</span> { <span class="com-single">// bar::foo is not the same as foo</span>
		<span class="keyword">void</span> <span class="func">f4</span>();

		<span class="keyword">namespace</span> <span class="namespace">baz</span> {
			<span class="keyword">void</span> <span class="func">f5</span>();
		}

		<span class="keyword">void</span> <span class="func">f6</span>();
	}
}

<span class="com-single">// definitions of entities can appear in another namespace definition...</span>
<span class="keyword">namespace</span> <span class="namespace">foo</span> { <span class="keyword">void</span> <span class="func">f1</span>() {} }
<span class="com-single">// ...or use qualified name</span>
<span class="keyword">void</span> <span class="namespace">foo</span>::<span class="func">f2</span>() {}

<span class="com-single">// inside a namespace, enclosing namespace names can be skipped</span>
<span class="com-single">// this applies to any code that uses entities from enclosed namespace</span>
<span class="keyword">namespace</span> <span class="namespace">bar</span> {
	<span class="keyword">void</span> <span class="func">f3</span>() {}
	<span class="keyword">void</span> <span class="namespace">foo</span>::<span class="func">f4</span>() {}      <span class="com-single">// no need to write bar::foo::f4</span>
	<span class="keyword">void</span> <span class="namespace">foo</span>::<span class="namespace">baz</span>::<span class="func">f5</span>() {} <span class="com-single">// no need to write bar::foo::baz::f5</span>
}

<span class="com-single">// out-of-namespace definitions and redeclarations can not appear</span>
<span class="com-single">// in a namespace that does not enclose original declaration</span>
<span class="keyword">namespace</span> <span class="namespace">xyz</span> {
	<span class="com-single">// error: xyz::bar::foo::f6 does not exist</span>
	<span class="com-single">// this syntax (qualified-id) can not be used to declare new entities</span>
	<span class="com-single">// void bar::foo::f6() {}</span>
}

<span class="com-single">// :: can be used before the name to refer to shadowed entity</span>
<span class="keyword">void</span> <span class="func">f</span>();
<span class="keyword">namespace</span> <span class="namespace">abc</span> {
	<span class="keyword">void</span> <span class="func">f</span>() <span class="com-single">// hides (shadows) global f</span>
	{
		::<span class="func">f</span>(); <span class="com-single">// ok: calls ::f (not a recursion)</span>
	}
}

<span class="com-single">// it's possible to create namespace aliases</span>
<span class="keyword">namespace</span> <span class="namespace">abc</span> {
	<span class="keyword">namespace</span> <span class="namespace">bfb</span> = ::<span class="namespace">bar</span>::<span class="namespace">foo</span>::<span class="namespace">baz</span>;
}

<span class="keyword">void</span> <span class="func">f7</span>()
{
	<span class="namespace">abc</span>::<span class="namespace">bfb</span>::<span class="func">f5</span>(); <span class="com-single">// ok: calls bar::foo::baz::f5</span>
}
</pre></td>
</tr></tbody></table></section><section id="code-class-code-custom-cpp-span-class-keyword-using-span-code"><h2><code class="code custom-cpp"><span class="keyword">using</span></code></h2>
<p>The keyword has 4 possible meanings, depending on the context:</p>
<ul class="simple">
<li><p>type aliases</p></li>
<li><p>using-declaration, inside classes (changes overloading rules in <em>derived</em> types)</p></li>
<li><p>using-declaration, outside classes (shortens names)</p></li>
<li><p>using-directive (shortens names)</p></li>
</ul>
<p>This article explains the last 2.</p>
</section><section id="using-declaration"><h2>Using-declaration</h2>
<p>Introduces names from other namespaces to current namespace or block scope (if used inside a function).</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">void</span> <span class="func">f</span>();

<span class="keyword">namespace</span> <span class="namespace">abc</span>
{
	<span class="keyword">void</span> <span class="func">g1</span>();
	<span class="keyword">void</span> <span class="func">g2</span>();
}

<span class="keyword">namespace</span> <span class="namespace">xyz</span>
{
	<span class="keyword">using</span> ::<span class="func">f</span>;
	<span class="keyword">using</span> <span class="namespace">abc</span>::<span class="func">g1</span>;
}

<span class="keyword">void</span> <span class="func">h</span>()
{
	<span class="namespace">xyz</span>::<span class="func">f</span>();  <span class="com-single">// calls ::f</span>
	<span class="namespace">xyz</span>::<span class="func">g1</span>(); <span class="com-single">// calls abc::g1</span>

	<span class="keyword">using</span> <span class="namespace">abc</span>::<span class="func">g2</span>;
	<span class="func">g2</span>(); <span class="com-single">// calls abc::g2</span>
}
</pre></td>
</tr></tbody></table>
<p>The declaration introduces all entities with specified name. In particular, the name can refer to a template or to a set of function overloads. The declaration applies only to entities that have already been declared:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">namespace</span> <span class="namespace">abc</span>
{
	<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">int</span>);
}
<span class="keyword">using</span> <span class="namespace">abc</span>::<span class="func">f</span>; <span class="com-single">// ::f is now a synonym for abc::f(int)</span>

<span class="keyword">namespace</span> <span class="namespace">abc</span>
{
	<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">char</span>); <span class="com-single">// does not change what ::f means</span>
}

<span class="keyword">void</span> <span class="func">foo</span>()
{
	<span class="func">f</span>(<span class="lit-chr">'a'</span>); <span class="com-single">// calls f(int), even though f(char) exists.</span>
}

<span class="keyword">void</span> <span class="func">bar</span>()
{
	<span class="keyword">using</span> <span class="namespace">abc</span>::<span class="func">f</span>; <span class="com-single">// introduces both overloads</span>
	<span class="func">f</span>(<span class="lit-chr">'a'</span>);       <span class="com-single">// calls f(char)</span>
}
</pre></td>
</tr></tbody></table>
<p><code class="code custom-cpp"><span class="keyword">using</span> <span class="keyword">namespace</span></code> does not have this behavior - for it the order of declarations is irrelevant (all names will be affected, not only ones defined before).</p>
<!-- TODO some recommendation? This looks really bad -->
<p>If using-declaration introduces names from different scopes, ambiguity errors appear only under specific usages. If using-declaration attempts to introduce something that is already in the current scope, it's an error.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">namespace</span> <span class="namespace">abc</span>
{
	<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">int</span>);
	<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">double</span>);

	<span class="keyword">void</span> <span class="func">g</span>(<span class="keyword">int</span>);
}

<span class="keyword">namespace</span> <span class="namespace">xyz</span>
{
	<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">int</span>);
	<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">double</span>);
	<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">char</span>);
}

<span class="keyword">void</span> <span class="func">g</span>();
<span class="com-single">// using abc::g; // error: g already in this scope</span>

<span class="com-single">// no error even though some overloads are identical</span>
<span class="keyword">using</span> <span class="namespace">abc</span>::<span class="func">f</span>;
<span class="keyword">using</span> <span class="namespace">xyz</span>::<span class="func">f</span>;

<span class="com-single">// void f(int); // error: conflicts with abc::f(int) and xyz::f(int)</span>

<span class="keyword">void</span> <span class="func">h</span>()
{
	<span class="func">f</span>(<span class="lit-chr">'h'</span>); <span class="com-single">// calls xyz::f(char)</span>
	<span class="func">f</span>(<span class="num">1.0</span>); <span class="com-single">// error: ambiguity between abc::f(double) and xyz::f(double)</span>
}
</pre></td>
</tr></tbody></table></section><section id="using-directive"><h2>Using-directive</h2>
<p>Similar to <em>using-declaration</em>, but introduces all names from specified namespace to the current scope.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">namespace</span> <span class="namespace">abc</span>
{
	<span class="keyword">int</span> <span class="var-global">i</span> = <span class="lit-num">1</span>;
	<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">char</span>);
}

<span class="keyword">namespace</span> <span class="namespace">foo</span>
{
	<span class="keyword">int</span> <span class="var-global">i</span> = <span class="lit-num">2</span>;
	<span class="keyword">int</span> <span class="var-global">j</span> = <span class="lit-num">3</span>;

	<span class="keyword">namespace</span> <span class="namespace">bar</span>
	{
		<span class="keyword">namespace</span> <span class="namespace">baz</span>
		{
			<span class="com-single">// names from abc injected into global namespace</span>
			<span class="com-single">// (including any names later declared in abc)</span>
			<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="namespace">abc</span>;

			<span class="keyword">int</span> <span class="var-global">j</span> = <span class="lit-num">4</span>;
			<span class="keyword">int</span> <span class="var-global">k</span> = <span class="lit-num">5</span>;
			<span class="keyword">int</span> <span class="var-global">a</span> = <span class="var-global">i</span>; <span class="com-single">// ok: foo::i hides abc::i</span>
		}

		<span class="com-single">// names from baz injected into bar</span>
		<span class="com-single">// names from abc injected into global namespace (using namespace is transitive)</span>
		<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="namespace">baz</span>;

		<span class="keyword">int</span> <span class="var-global">l</span> = <span class="var-global">k</span>; <span class="com-single">// ok, uses baz::k</span>
		<span class="keyword">int</span> <span class="var-global">k</span> = <span class="lit-num">6</span>; <span class="com-single">// ok, no name conflict</span>
		<span class="keyword">int</span> <span class="var-global">m</span> = <span class="problem">k</span>; <span class="com-single">// error: bar::k or baz::k?</span>
		<span class="keyword">int</span> <span class="var-global">n</span> = <span class="var-global">i</span>; <span class="com-single">// ok: foo::i hides abc::i</span>
		<span class="keyword">int</span> <span class="var-global">o</span> = <span class="var-global">j</span>; <span class="com-single">// ok: baz::j hides foo::j</span>
	}
}

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="namespace">abc</span>;

<span class="keyword">namespace</span> <span class="namespace">xyz</span>
{
	<span class="keyword">int</span> <span class="var-global">e</span> = <span class="lit-num">7</span>;
	<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">int</span>);
}

<span class="keyword">namespace</span> <span class="namespace">abc</span>
{
	<span class="keyword">int</span> <span class="var-global">d</span> = <span class="lit-num">8</span>;
	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="namespace">xyz</span>;
	<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">int</span>);
}

<span class="keyword">int</span> <span class="var-global">d</span> = <span class="lit-num">9</span>;

<span class="keyword">void</span> <span class="func">func</span>()
{
	++<span class="problem">d</span>;      <span class="com-single">// error: ::d or abc::d?</span>
	++::<span class="var-global">d</span>;    <span class="com-single">// ok</span>
	++<span class="namespace">abc</span>::<span class="var-global">d</span>; <span class="com-single">// ok</span>
	++<span class="var-global">e</span>;      <span class="com-single">// ok (using namespace is transitive)</span>

	<span class="problem">f</span>(<span class="lit-num">1</span>);     <span class="com-single">// error: xyz::f(int) or abc::f(int)?</span>
	<span class="func">f</span>(<span class="lit-chr">'a'</span>);   <span class="com-single">// ok: abc::f(char)</span>
}
</pre></td>
</tr></tbody></table>
<section id="code-class-code-custom-cpp-span-class-keyword-using-span-span-class-keyword-namespace-span-span-class-namespace-std-span-code"><h3><code class="code custom-cpp"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="namespace">std</span>;</code></h3>
<p>Shortly speaking, one of the most overused statements in C++. There is so much to say about it that <strong>I wrote a separate article about it</strong>. TOLINK</p>
</section></section><section id="code-class-code-custom-cpp-span-class-keyword-using-span-span-class-keyword-enum-span-code"><h2><code class="code custom-cpp"><span class="keyword">using</span> <span class="keyword">enum</span></code></h2>
<p>Since C++20 it's also possile to bring enumerator names into enclosing scope.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="type">fruit</span> { <span class="enum">apple</span>, <span class="enum">orange</span> };
<span class="keyword">enum</span> <span class="keyword">class</span> <span class="type">color</span> { <span class="enum">green</span>, <span class="enum">orange</span>, <span class="enum">red</span> };

<span class="keyword">struct</span> <span class="type">boo</span>
{
	<span class="keyword">using</span> <span class="keyword">enum</span> <span class="type">fruit</span>;
};

<span class="keyword">void</span> <span class="func">f</span>()
{
	<span class="com-single">// ok: auto = fruit</span>
	<span class="keyword">auto</span> <span class="var-local">x</span> = <span class="type">boo</span>::<span class="enum">orange</span>;
	<span class="com-single">// also ok, but I wouldn't write such code</span>
	<span class="com-single">// I guess this syntax is allowed to make writing templates easier</span>
	<span class="type">boo</span> <span class="var-local">b</span>;
	<span class="keyword">auto</span> <span class="var-local">y</span> = <span class="var-local">b</span>.<span class="enum">orange</span>;
}

<span class="keyword">void</span> <span class="func">g</span>()
{
	<span class="keyword">using</span> <span class="keyword">enum</span> <span class="type">fruit</span>; <span class="com-single">// ok: you can now use apple and orange</span>
	<span class="keyword">using</span> <span class="keyword">enum</span> <span class="type">color</span>; <span class="com-single">// error: fruit::orange and color::orange conflict</span>
}
</pre></td>
</tr></tbody></table>
<p>It's also possible to do it for single enumerators by writing code like <code class="code custom-cpp"><span class="keyword">using</span> <span class="type">color</span>::<span class="enum">red</span></code>.</p>
</section><section id="anonymous-namespaces"><h2>Anonymous namespaces</h2>
<p>Formally <em>unnamed-namespace-definition</em> but the "anonymous" term is very popular in the community. Works as if the namespace has some unique name and is immediately followed by <code class="code custom-cpp"><span class="keyword">using</span> <span class="keyword">namespace</span></code>. Can also be mentally understood as "not actually enclosing entities in any namespace".</p>
<p><strong>Everything defined inside anonymous namespaces has internal linkage.</strong> This includes named namespaces inside. The purpose of this feature is to further reduce name conflicts, but specifically across TUs. You should put there all things that are not being used outside of current source file and do not need to be visible to other TUs.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="com-single">// header</span>
<span class="namespace">std</span>::<span class="type">string</span> <span class="func">important_complex_function</span>(<span class="keyword">int</span> <span class="param">x</span>, <span class="keyword">int</span> <span class="param">y</span>, <span class="keyword">double</span> <span class="param">n</span>)

<span class="com-single">// source</span>
<span class="keyword">namespace</span> {
	<span class="com-single">// many helper functions that are used only in this file</span>
	<span class="com-single">// all will have *internal linkage*</span>
	<span class="com-single">// the same names can be reused in other TUs</span>
}

<span class="namespace">std</span>::<span class="type">string</span> <span class="func">important_complex_function</span>(<span class="keyword">int</span> <span class="param">x</span>, <span class="keyword">int</span> <span class="param">y</span>, <span class="keyword">double</span> <span class="param">n</span>)
{
	<span class="com-single">// uses many helper functions...</span>
}
</pre></td>
</tr></tbody></table>
<p>You might notice that the same functionality was already presented with <code class="code custom-cpp"><span class="keyword">static</span></code> - anonymous namespaces should be preferred. Why? See these:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions">https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions</a></p></li>
<li><p><a class="reference external" href="https://stackoverflow.com/questions/4977252/why-an-unnamed-namespace-is-a-superior-alternative-to-static">https://stackoverflow.com/questions/4977252/why-an-unnamed-namespace-is-a-superior-alternative-to-static</a></p></li>
</ul>
<aside class="admonition tip"><p class="admonition-title">tip</p>
<p>Do not use anonymous namespaces or <code class="code custom-cpp"><span class="keyword">static</span></code> entities - basically any way of specifyng <em>internal linkage</em> in header files. They are specifically for code that is intended to not be shared and headers are specifically to do the opposite.</p>
</aside></section><section id="inline-namespaces"><h2>Inline namespaces</h2>
<p>Inline namespaces work similarly to anonymous namespaces - names are available in enclosing namespace, as if there was a <code class="code custom-cpp"><span class="keyword">using</span> <span class="keyword">namespace</span></code> directive after it's definition. There are no changes in linkage though.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">namespace</span> <span class="namespace">foo</span> {
	<span class="keyword">inline</span> <span class="keyword">namespace</span> <span class="namespace">bar</span> {
		<span class="keyword">void</span> <span class="func">f</span>();

		<span class="keyword">inline</span> <span class="keyword">namespace</span> <span class="namespace">baz</span> {
			<span class="keyword">void</span> <span class="func">g</span>();
		}
	}
}

<span class="keyword">void</span> <span class="func">func</span>()
{
	<span class="com-single">// namespace names can be specified explicitly</span>
	<span class="namespace">foo</span>::<span class="namespace">bar</span>::<span class="func">f</span>();
	<span class="namespace">foo</span>::<span class="namespace">bar</span>::<span class="namespace">baz</span>::<span class="func">g</span>();

	<span class="com-single">// namespace names can have inline namespaces ommitted</span>
	<span class="namespace">foo</span>::<span class="func">f</span>();
	<span class="namespace">foo</span>::<span class="func">g</span>();
}
</pre></td>
</tr></tbody></table>
<aside class="admonition note"><p class="admonition-title">note</p>
<p><code class="code custom-cpp"><span class="keyword">inline</span> <span class="keyword">namespace</span></code> must be specified at the first definition. Any later definition can skip the keyword <code class="code custom-cpp"><span class="keyword">inline</span></code>.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="com-single">// bad</span>
<span class="keyword">namespace</span> <span class="namespace">lib</span> {}
<span class="problem">inline</span> <span class="problem">namespace</span> <span class="problem">lib</span> {} <span class="com-single">// error: inline namespace must be specified at initial definition</span>

<span class="com-single">// good</span>
<span class="keyword">inline</span> <span class="keyword">namespace</span> <span class="namespace">lib</span> {}
<span class="keyword">inline</span> <span class="keyword">namespace</span> <span class="namespace">lib</span> {}

<span class="com-single">// also good</span>
<span class="keyword">inline</span> <span class="keyword">namespace</span> <span class="namespace">lib</span> {}
<span class="keyword">namespace</span> <span class="namespace">lib</span> {}
</pre></td>
</tr></tbody></table>
<p>Because order of includes can change (and potentially break code which skips the keyword), my recommendation is to never skip <code class="code custom-cpp"><span class="keyword">inline</span></code>. This will also make the code more consistent and less surprising for any readers.</p>
</aside><p>This feature has 2 purposes.</p>
<section id="finely-grained-usings"><h3>Finely-grained usings</h3>
<p>Names are available in enclosing scopes, without having to specify their inline namespace name. But using directives can be more selective. Below is an example with standard library <em>user-defined literals</em>.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="com-single">// synopsis from standard library implementation</span>
<span class="keyword">namespace</span> <span class="namespace">std</span> {

	<span class="keyword">inline</span> <span class="keyword">namespace</span> <span class="namespace">literals</span> {
		<span class="com-single">// note: there are more literal overloads than listed here</span>

		<span class="keyword">inline</span> <span class="keyword">namespace</span> <span class="namespace">string_literals</span> {
			<span class="keyword">constexpr</span> <span class="type">string</span> <span class="keyword">operator</span>""<span class="suf">s</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="param">str</span>, <span class="type">size_t</span> <span class="param">len</span>); <span class="com-single">// constexpr since C++20</span>
		}

		<span class="keyword">inline</span> <span class="keyword">namespace</span> <span class="namespace">chrono_literals</span> {
			<span class="keyword">constexpr</span> <span class="namespace">chrono</span>::<span class="type">seconds</span> <span class="keyword">operator</span>""<span class="suf">s</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="param">secs</span>);
		}
	}

	<span class="keyword">namespace</span> <span class="namespace">chrono</span> {
		<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="namespace">literals</span>::<span class="namespace">chrono_literals</span>;
	}

}

<span class="com-single">// example uses</span>
{
	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="namespace">std</span>; <span class="com-single">// makes both suffixes visible</span>
	<span class="keyword">auto</span> <span class="var-local">str</span> = <span class="lit-str">"abc"</span><span class="suf">s</span>; <span class="com-single">// auto = std::string</span>
	<span class="keyword">auto</span> <span class="var-local">min</span> = <span class="lit-num">60</span><span class="suf">s</span>;    <span class="com-single">// auto = std::chrono::seconds</span>
}

{
	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="namespace">std</span>::<span class="namespace">literals</span>; <span class="com-single">// makes both suffixes visible</span>
	<span class="keyword">auto</span> <span class="var-local">str</span> = <span class="lit-str">"abc"</span><span class="suf">s</span>;
	<span class="keyword">auto</span> <span class="var-local">min</span> = <span class="lit-num">60</span><span class="suf">s</span>;
}

{
	<span class="keyword">using</span> <span class="namespace">std</span>::<span class="keyword">operator</span><span class="str">""</span><span class="suf">s</span>; <span class="com-single">// makes both suffixes visible</span>
	<span class="keyword">auto</span> <span class="var-local">str</span> = <span class="lit-str">"abc"</span><span class="suf">s</span>;
	<span class="keyword">auto</span> <span class="var-local">min</span> = <span class="lit-num">60</span><span class="suf">s</span>;
}

{
	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="namespace">std</span>::<span class="namespace">string_literals</span>; <span class="com-single">// string literal suffixes only</span>
	<span class="keyword">auto</span> <span class="var-local">str</span> = <span class="lit-str">"abc"</span><span class="suf">s</span>;
}

{
	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="namespace">std</span>::<span class="namespace">chrono_literals</span>; <span class="com-single">// chrono literal suffixes only</span>
	<span class="keyword">auto</span> <span class="var-local">min</span> = <span class="lit-num">60</span><span class="suf">s</span>;
}

{
	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="namespace">std</span>::<span class="namespace">chrono</span>; <span class="com-single">// all std::chrono names, including suffixes</span>
	<span class="keyword">auto</span> <span class="var-local">min</span> = <span class="lit-num">60</span><span class="suf">s</span>;
	<span class="keyword">auto</span> <span class="var-local">sec</span> = <span class="type">seconds</span>(<span class="lit-num">1</span>); <span class="com-single">// auto = std::chrono::seconds</span>
}
</pre></td>
</tr></tbody></table></section><section id="versioning-support"><h3>Versioning support</h3>
<p>Users of a library can refer to specific names or use a default one if automatic behavior updates are desired.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="com-single">// before update</span>
<span class="keyword">namespace</span> <span class="namespace">lib</span> {

	<span class="keyword">inline</span> <span class="keyword">namespace</span> <span class="namespace">v1</span> {
		<span class="keyword">void</span> <span class="func">func</span>();
	}

}

<span class="com-single">// after update</span>
<span class="keyword">namespace</span> <span class="namespace">lib</span> {

	<span class="keyword">namespace</span> <span class="namespace">v1</span> {
		<span class="keyword">void</span> <span class="func">func</span>();
	}

	<span class="keyword">inline</span> <span class="keyword">namespace</span> <span class="namespace">v2</span> {
		<span class="keyword">void</span> <span class="func">func</span>();
	}

}

<span class="keyword">void</span> <span class="func">user_function</span>()
{
	<span class="namespace">lib</span>::<span class="namespace">v1</span>::<span class="func">func</span>(); <span class="com-single">// always first version</span>

	<span class="com-single">// before update: v1::func</span>
	<span class="com-single">// after update: v2::func</span>
	<span class="namespace">lib</span>::<span class="func">func</span>();
}
</pre></td>
</tr></tbody></table>
<!-- it's a huge failure that in 2022 reST is not capable of nesting inline markup --><!-- I have to use 2 replacements to make a bold link --><!-- https://stackoverflow.com/a/4836544/4818802 --><p>Apart from being able to select a specific version or use a default, there is one additional important functionality: <strong>inline namespaces affect</strong> <a class="reference external" href="https://en.wikipedia.org/wiki/Name_mangling"><strong>name mangling</strong></a>. What are benefits of this? Suppose a such situation:</p>
<ul class="simple">
<li><p>the programmer compiles library version 1</p></li>
<li><p>the programmer writes some code that uses the library and compiles it</p></li>
<li><p>the programmer updates the library and compiles version 2</p></li>
<li><p>library-using-code is not recompiled and only the compiled library object (e.g. <code class="docutils literal">.so</code> or <code class="docutils literal">.dll</code> file) is replaced</p></li>
</ul>
<p>This can result in undefined behavior due to ODR violations. The library-using-code was compiled with version 1 definitions, but actually linked with version 2. The executable can crash because there can be mismatches between expected and actual size/alignment of structures and many other machine-instruction-level details:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">namespace</span> <span class="namespace">gis</span> {

	<span class="keyword">struct</span> <span class="type">geo_zone</span> {
		<span class="com-single">// [...]</span>
		<span class="com-single">// additional and/or reordered members in newer version</span>
	};

}

<span class="keyword">void</span> <span class="func">user_func</span>()
{
	<span class="com-single">// compiled user code with old version (function-local object):</span>
	<span class="com-single">// allocates sizeof(gis::geo_zone) bytes on the stack with alignof(gis::geo_zone) alignment</span>
	<span class="com-single">// compiled library code with new version (library function):</span>
	<span class="com-single">// writes sizeof(gis::geo_zone) bytes, *this size may differ from size in user code*</span>
	<span class="com-single">// result: possible stack memory corruption, overwrite of other data on the stack</span>
	<span class="namespace">gis</span>::<span class="type">geo_zone</span> <span class="var-local">gz</span> = <span class="namespace">gis</span>::<span class="func">some_func</span>();
	<span class="com-single">// compiled user code with old version (member of a type):</span>
	<span class="com-single">// passes to the function memory address of gz, adjusted by offsetof(gis::geo_zone, time_zone)</span>
	<span class="com-single">// compiled library code with new version (library function):</span>
	<span class="com-single">// expects the struct member at a different offset, may break under some optimizations</span>
	<span class="namespace">gis</span>::<span class="func">other_func</span>(<span class="var-local">gz</span>.<span class="var-member">time_zone</span>);
}
</pre></td>
</tr></tbody></table>
<p>Such situation is known as <strong>ABI mismatch</strong> or <strong>ABI breakage</strong>. ABI stands for <em>application binary interface</em>. It's different from <strong>API</strong> (<em>application programming interface</em>) - API pertains to compatibility at the source code level, ABI pertains to compatibility at binary (compiled code) level.</p>
<aside class="admonition note"><p class="admonition-title">note</p>
<p>It's possible to make an API-breaking change that does not break the ABI and also to make an ABI-breaking change that does not break the API. The latter is dangerous because the build can succeed and contain undefined behavior due to ODR violations.</p>
</aside><aside class="admonition note"><p class="admonition-title">note</p>
<p>Sometimes no code changes are needed to break the ABI. Some compiler options can affect it too!</p>
</aside><aside class="admonition note"><p class="admonition-title">note</p>
<p>C++ does not specify ABI at all so it's completely <em>implementation-defined</em> what affects it and what changes are ABI-breaking. Many implementations (especially for non-Windows platforms) adhere to <a class="reference external" href="https://itanium-cxx-abi.github.io/cxx-abi/">Itanium C++ ABI</a>.</p>
</aside><aside class="admonition note"><p class="admonition-title">note</p>
<p>Some libraries commit to maintaining stable ABI. This means that you do not have to recompile library-using-code if the library is updated and rebuilt as no machine-instruction-level incompatibilities are introduced. The benefit of this approach is that you don't have to constantly recompile your code upon library update (this is especially useful for system package updates on GNU/Linux distributions); the drawback is that such practice limits possible changes in code and/or requires indirection techniques like <em>PIMPL</em> to support it.</p>
</aside><p>If inline namespaces are used (and changed every time an ABI-breaking change is introduced) such problem can be detected at linking step because compiled entities will have different symbol names - inline namespaces will be present in <em>mangled names</em>.</p>
<p>Using inline namespaces in such case is superior to preprocessor-based solutions because inline namespaces allow providing different definitions for different versions in the same build. If there are disjoint parts of code that use different versions, there are no problems - since these parts don't interact they have no conflicts. As if they used different entities.</p>
<p>As of C++20, the standard library officially does not use inline namespaces for this functionality, but some implementations use it internally - Clang's libc++ uses <code class="code custom-cpp"><span class="keyword">inline</span> <span class="keyword">namespace</span> <span class="namespace">__1</span></code>. This will help detect ODR violations if compiled code is mixed across versions with different implementations.</p>
</section></section><section id="syntax-sugar"><h2>Syntax sugar</h2>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="com-single">// C++17 - multiple usings in one statement</span>
<span class="keyword">using</span> ::<span class="func">f</span>; <span class="keyword">using</span> <span class="namespace">abc</span>::<span class="func">g</span>; <span class="keyword">using</span> <span class="namespace">xyz</span>::<span class="func">h</span>;
<span class="keyword">using</span> ::<span class="func">f</span>, <span class="namespace">abc</span>::<span class="func">g</span>, <span class="namespace">xyz</span>::<span class="func">h</span>;

<span class="com-single">// C++17 - defining nested namespaces with one keyword and one {}</span>
<span class="keyword">namespace</span> <span class="namespace">na</span> { <span class="keyword">namespace</span> <span class="namespace">nb</span> { <span class="keyword">namespace</span> <span class="namespace">nc</span> { <span class="com-multi">/* ... */</span> }}}
<span class="keyword">namespace</span> <span class="namespace">na</span>::<span class="namespace">nb</span>::<span class="namespace">nc</span> { <span class="com-multi">/* ... */</span> } <span class="com-single">// no prior appearance of na and na::nb is required</span>

<span class="com-single">// C++20 - additionally supports inline</span>
<span class="keyword">namespace</span> <span class="namespace">nd</span>::<span class="namespace">ne</span> { <span class="keyword">inline</span> <span class="keyword">namespace</span> <span class="namespace">nf</span> { <span class="com-multi">/* ... */</span> }}
<span class="keyword">namespace</span> <span class="namespace">nd</span>::<span class="namespace">ne</span>::<span class="keyword">inline</span> <span class="namespace">nf</span> { <span class="com-multi">/* ... */</span> }

<span class="keyword">namespace</span> <span class="namespace">ng</span> { <span class="keyword">inline</span> <span class="keyword">namespace</span> <span class="namespace">nh</span> { <span class="keyword">namespace</span> <span class="namespace">ni</span> { <span class="com-multi">/* ... */</span> }}}
<span class="keyword">namespace</span> <span class="namespace">ng</span>::<span class="keyword">inline</span> <span class="namespace">nh</span>::<span class="namespace">ni</span> { <span class="com-multi">/* ... */</span> }
</pre></td>
</tr></tbody></table></section><section id="recommendation"><h2>Recommendation</h2>
<ul class="simple">
<li><p>Size of a namespace: no consensus in the community. Some libraries put almost everything in a first-level namespace (like 1000+ names) (<code class="code custom-cpp"><span class="namespace">std</span></code> is a very good example), others do many layers with &lt;100 names per namespace. Core Guidelines: as of writing this, namespace size is under to-do section.</p></li>
<li><p>Avoid name conflicts. You won't need to memorize what happens when ambiguities appear. And I haven't even listed all possible cases.</p></li>
<li><p>Prefer function-local usings to namespace-level usings.</p></li>
<li><p>Prefer usings for specific names like <code class="code custom-cpp"><span class="keyword">using</span> <span class="namespace">std</span>::<span class="var-global">cout</span>;</code> instead of whole-namespace usings like <code class="code custom-cpp"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="namespace">std</span>;</code>.</p></li>
<li><p>If a conflict would arise, create name or namespace aliases instead to shorten names only (no scope changes) - e.g. <code class="code custom-cpp"><span class="keyword">namespace</span> <span class="namespace">bc</span> = <span class="namespace">boost</span>::<span class="namespace">container</span>;</code> allows short <code class="code custom-cpp"><span class="namespace">bc</span>::<span class="type">vector</span></code> which does not conflict with <code class="code custom-cpp"><span class="namespace">std</span>::<span class="type">vector</span></code>.</p></li>
<li><p>Avoid <code class="code custom-cpp"><span class="keyword">using</span> <span class="keyword">namespace</span></code> in headers. It can hijack code that (potentially transitively) accidentally includes a header with this directive.</p></li>
</ul>
<p>Similar recommendations are present in Core Guidelines. Like many other mechanisms in the language, it can be very useful but if abused, it can lead to non-trivial errors and complex situations (especially name shadowing).</p>
</section>
</div>
 		<footer class="footer"><div class="footer-item footer-item-container">
				<div class="footer-flex-item">
					<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">
						<img alt="Creative Commons License" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a>
					<br>
					All non-code content licensed under <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, unless stated otherwise.
				</div>
				<div class="footer-flex-item">
					All code content (monospaced font) licensed under <a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/">Creative Commons Zero License</a>, unless stated otherwise.
				</div>
			</div>
			<div class="footer-item footer-item-container">
				<div class="footer-flex-item">
					Generated using heavily customized <a href="https://getnikola.com">Nikola</a> static site generator.
				</div>
				<div class="footer-flex-item">
					<a href="https://github.com/Xeverous/the_website">website repository and issue tracker</a>
				</div>
			</div>
		</footer>
</div>
	</div>
</body>
</html>
