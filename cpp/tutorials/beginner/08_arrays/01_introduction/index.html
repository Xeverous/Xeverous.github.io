<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!-- Enable responsiveness on mobile devices--><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title>modern C++ by Xeverous - 01 - introduction</title>
<link rel="icon" href="favicon.png">
<!-- RSS --><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../../../atom.xml">
<!-- CSS --><link rel="stylesheet" href="../../../../../assets/css/styles.css">
<!-- JS --><script type="text/javascript" src="../../../../../assets/js/app.js" defer></script><!-- maybe later
	<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']]
    },
    showMathMenu: false,
    menuSettings: {
      zoom: "None",
      collapsible: false,
      autocollapse: false,
      explorer: false
    }
  });
        </script>
	<script type="text/javascript" async
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"
		async></script>
	-->
</head>
<body>
	<div class="layout">
 <nav class="sidebar"><ul>
<li class="sidebar-section">
			<ul>
<li><a href="../../../../../">HOME</a></li>
				<li><a href="../../../../../index">INDEX</a></li>
			</ul>
</li>

			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ tutorials</h4>
				<p class="sidebar-section-description">Learn C++ from begin() to the end() (and beyond) or use knowledge and experience gained in other languages in the accelerated tutorial.</p>

				<ul>
<li><a href="../../">beginner</a></li>
						<li><a href="../../../accelerated/">accelerated</a></li>
						<li><a href="../../../templates/">templates</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ how-to</h4>
				<p class="sidebar-section-description">Common and specific tasks explained.</p>

				<ul>
<li><a href="../../../../stdlib/">standard library components</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">C++ utilities</h4>
				<p class="sidebar-section-description">Various metarials with concentrated information.</p>

				<ul>
<li><a href="../../../../utility/cheatsheets/">C++ cheatsheets</a></li>
						<li><a href="../../../../utility/cpp_faq/">C++ FAQ</a></li>
						<li><a href="../../../../utility/cpp_myths/">C++ myths</a></li>
						<li><a href="../../../../utility/glossary/">glossary</a></li>
						<li><a href="../../../../utility/">(all articles)</a></li>
				</ul>
</li>
			<li class="sidebar-section">
				<h4 class="sidebar-section-title">misc / meta</h4>
				<p class="sidebar-section-description">About this website and its authors.</p>

				<ul>
<li><a href="../../../../../about/">about</a></li>
						<li><a href="../../../../../meta/site_faq/">website FAQ</a></li>
						<li><a href="../../../../../meta/markdown_test/">Markdown test page</a></li>
						<li><a href="../../../../../meta/rest_test/">reStructuredText test page</a></li>
				</ul>
</li>
	</ul></nav><nav class="topbar"><ul class="menu">
<li class="button"><a href="../../../../../">HOME</a></li>
				<li class="button"><a href="../../../../../index">INDEX</a></li>
				<li class="button"><a href="../../../../../faq">FAQ</a></li>
				<li class="button"><a href="../../../../../about">ABOUT</a></li>
				<li class="button menu-button">
					<div class="menu-icon">
						<div class="bar1"></div>
						<div class="bar2"></div>
						<div class="bar3"></div>
					</div>
				</li>
			</ul></nav><div class="main container">
				<nav class="breadcrumb"><ol>
<li><a href="../../../../../index">index</a></li>
						<span>/</span>
							<li><a href="../../../../">C++</a></li>
							<span>/</span>
							<li><a href="../../../">tutorials</a></li>
							<span>/</span>
							<li><a href="../../">beginner</a></li>
							<span>/</span>
							<li><a href="../">08 - arrays</a></li>
							<span>/</span>
						<li>01 - introduction</li>
					</ol></nav><div class="content">
				<h1>01 - introduction</h1>				<!-- TODO explain array initialization from const char[N] -->
<p>You may have noticed that sometimes the code contains variables named like <code class="docutils literal">x1</code>, <code class="docutils literal">x2</code>, <code class="docutils literal">x3</code>. Multiple objects of the same type are used for the same purpose. You may write functions to reuse logic on multiple objects, but even calling functions with a group of same variables gets repetitive and we know that duplicate code is a really bad thing.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">int</span> <span class="var-local">x1</span> = <span class="lit-num">1</span>;
<span class="keyword">int</span> <span class="var-local">x2</span> = <span class="lit-num">2</span>;
<span class="keyword">int</span> <span class="var-local">x3</span> = <span class="lit-num">3</span>;

<span class="keyword">int</span> <span class="var-local">y1</span> = <span class="func">f</span>(<span class="var-local">x1</span>);
<span class="keyword">int</span> <span class="var-local">y2</span> = <span class="func">f</span>(<span class="var-local">x2</span>);
<span class="keyword">int</span> <span class="var-local">y3</span> = <span class="func">f</span>(<span class="var-local">x3</span>);

<span class="com-single">// any other operation will likely have another 3 similar lines...</span>
</pre></td>
</tr></tbody></table>
<section id="object-variable-relationship"><h2>Object-variable relationship</h2>
<p>Recall the difference between an object and a variable:</p>
<ul class="simple">
<li><p>An object is data in memory.</p></li>
<li><p>A variable is an abstraction, a name that refers to (potentially multiple) objects.</p></li>
</ul>
<p>So far there were examples of n:1 variable-object relation (multiple references to the same object), now it's time for 1:n (one variable for multiple objects).</p>
</section><section id="arrays"><h2>Arrays</h2>
<aside class="admonition definition"><p class="admonition-title">definition</p>
<p>An array object is an object that consists of multiple contiguously allocated objects of the same type.</p>
</aside><table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">int</span> <span class="var-local">x</span>[<span class="lit-num">3</span>] = {<span class="lit-num">1</span>, <span class="lit-num">2</span>, <span class="lit-num">3</span>};

<span class="keyword">int</span> <span class="var-local">y</span>[<span class="lit-num">3</span>]; <span class="com-single">// (uninitialized)</span>
<span class="var-local">y</span>[<span class="lit-num">0</span>] = <span class="func">f</span>(<span class="var-local">x</span>[<span class="lit-num">0</span>]);
<span class="var-local">y</span>[<span class="lit-num">1</span>] = <span class="func">f</span>(<span class="var-local">x</span>[<span class="lit-num">1</span>]);
<span class="var-local">y</span>[<span class="lit-num">2</span>] = <span class="func">f</span>(<span class="var-local">x</span>[<span class="lit-num">2</span>]);
</pre></td>
</tr></tbody></table>
<p>The example looks differently and few things need to be explained.</p>
</section><section id="syntax"><h2>Syntax</h2>
<p>Intuitively, you might expect the syntax to be a bit different:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">int</span>[<span class="lit-num">10</span>] <span class="var-local">arr</span>; <span class="com-single">// expected: arr represents 10 integers</span>
<span class="keyword">int</span> <span class="var-local">arr</span>[<span class="lit-num">10</span>]; <span class="com-single">// actual: a bit weird/inconsistent order</span>
</pre></td>
</tr></tbody></table>
<p>Recall one of the first lessons - <strong>declarator syntax is not "type followed by name"</strong> and unfortunately due to backwards compatibility, it can not be changed.</p>
<blockquote>
<p>So is there any lesson about declarator syntax?</p>
</blockquote>
<p>No, at least not now. But the problem is old enough that you may find various resources on the internet that may help you, e.g. <a class="reference external" href="https://cdelc.org">https://cdelc.org</a>. Here, I will post examples when needed as I don't think spending time trying to understand this part of C grammar is worth it. In practice, there are C++ alternatives and actual "syntax abonimations" are pretty rare so people usually just remember them instead of understanding. Explaining the C (and C++) language grammar could be a separate course on its own.</p>
<p>The good news for arrays is that we will not use this syntax for long, as C++11 added an alternative, which is much better and not only in syntax. But first, let's explain some aspects of arrays.</p>
</section><section id="indexing"><h2>Indexing</h2>
<p><strong>Arrays are zero-indexed.</strong> This means that an array of size <code class="docutils literal">n</code> has objects under indexes <code class="docutils literal">0 ... <span class="pre">n-1</span></code>. In the example above both arrays are of size 3 and their valid indexes are 0, 1, 2.</p>
<p>If this is the first time you encounter 0-based indexing you might be a bit confused, but <strong>the more you dwell into programming the more appropriately it will sound</strong>. Once you gain enough knowledge, it will be obvious that zero-based indexing is the only proper way of dealing with arrays.</p>
<p>The primary reason for zero-based indexing is related to how arrays work underneath - variables that refer to contiguously allocated objects (next to each other) of the same type. A good comparison (which may be surprising, depending where do you live) is floor numbering - ground floor is floor 0, first floor is 1, second is 2 and so on. If you are not used to this type of indexing, I have to inform you that this is the European convention and elevators there do have a 0 floor button.</p>
<p>An array starts at a specific memory address and it's first element is placed right in the beginning:</p>
<!-- teaching note: the example below uses std::addressof on purpose: for readability and to avoid pointers -->
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="pp-hash">#</span><span class="pp-directive">include</span> <span class="pp-header">&lt;memory&gt;</span> <span class="com-single">// for std::addressof</span>
<span class="pp-hash">#</span><span class="pp-directive">include</span> <span class="pp-header">&lt;iostream&gt;</span>

<span class="keyword">int</span> <span class="func">main</span>()
{
	<span class="keyword">int</span> <span class="var-local">arr</span>[<span class="lit-num">3</span>] = {<span class="lit-num">1</span>, <span class="lit-num">2</span>, <span class="lit-num">3</span>};

	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="namespace">std</span>::<span class="func">addressof</span>(<span class="var-local">arr</span>) <span class="oo">&lt;&lt;</span> <span class="lit-str">"<span class="esc-seq">\n</span>"</span>;
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="namespace">std</span>::<span class="func">addressof</span>(<span class="var-local">arr</span>[<span class="lit-num">0</span>]) <span class="oo">&lt;&lt;</span> <span class="lit-str">"<span class="esc-seq">\n</span>"</span>;
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="namespace">std</span>::<span class="func">addressof</span>(<span class="var-local">arr</span>[<span class="lit-num">1</span>]) <span class="oo">&lt;&lt;</span> <span class="lit-str">"<span class="esc-seq">\n</span>"</span>;
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="namespace">std</span>::<span class="func">addressof</span>(<span class="var-local">arr</span>[<span class="lit-num">2</span>]) <span class="oo">&lt;&lt;</span> <span class="lit-str">"<span class="esc-seq">\n</span>"</span>;
}
</pre></td>
</tr></tbody></table>
<div class="code"><pre class="code text"><a id="rest_code_3db6d5849d944094b58a6ae351a64c2f-1" name="rest_code_3db6d5849d944094b58a6ae351a64c2f-1" href="#rest_code_3db6d5849d944094b58a6ae351a64c2f-1"></a>0x7ffdc1562d04
<a id="rest_code_3db6d5849d944094b58a6ae351a64c2f-2" name="rest_code_3db6d5849d944094b58a6ae351a64c2f-2" href="#rest_code_3db6d5849d944094b58a6ae351a64c2f-2"></a>0x7ffdc1562d04
<a id="rest_code_3db6d5849d944094b58a6ae351a64c2f-3" name="rest_code_3db6d5849d944094b58a6ae351a64c2f-3" href="#rest_code_3db6d5849d944094b58a6ae351a64c2f-3"></a>0x7ffdc1562d08
<a id="rest_code_3db6d5849d944094b58a6ae351a64c2f-4" name="rest_code_3db6d5849d944094b58a6ae351a64c2f-4" href="#rest_code_3db6d5849d944094b58a6ae351a64c2f-4"></a>0x7ffdc1562d0c
</pre></div>
<p>Standard streams print memory addresses using base 16 (extra 6 digits are denoted with a-f) but you can clearly see that the address of the first array element is the same as the address of the array. Obviously if you run the same program the output may be different but <strong>first 2 lines will always be identical</strong>. This lack of difference is the reason for 0 based numbering - during <em>pointer arithmetics</em> (which are far from this lesson) the index is used to calculate memory address of specific object and if it wasn't 0-based indexing, the math would simply not work.</p>
<aside class="admonition error"><p class="admonition-title">error</p>
<p>Accessing an element with invalid index in an array is undefined behavior.</p>
</aside><p>The reason for the above is simple: if you use an index that is outside valid range, a machine instruction will be generated that tries to access memory outside what has been allocated for the array. Such bug will usually either immediately crash the program or corrupt memory of something else that will later lead to a crash and/or other faulty behavior.</p>
</section><section id="array-size"><h2>Array size</h2>
<p>Array size must be a constant expression, that is, an expression that can be evaluated at compile time.</p>
<blockquote>
<p>So array size must be <code class="code custom-cpp"><span class="keyword">constexpr</span></code>?</p>
</blockquote>
<p>Generally, this is a good mental shortcut because <code class="code custom-cpp"><span class="keyword">constexpr</span></code> values can be used as array size, but many other language constructs can create constant expressions too. These constructs are mostly special rules for various use cases (especially <code class="code custom-cpp"><span class="keyword">const</span></code>) that were present before C++11 introduced <code class="code custom-cpp"><span class="keyword">constexpr</span></code>. <a class="reference external" href="https://en.cppreference.com/w/cpp/language/constant_expression">The list is long</a> but without these rules, one would need to use preprocessor or even worse tricks to manipulate constants - and you should know that C++ (unlike C) really hates macros. <code class="code custom-cpp"><span class="keyword">const</span></code> in C is absent of these rules and const-qualified objects there can not be used for things such as an array size, even if the value is computable at compile time. This caused 3 conventions to emerge:</p>
<ul class="simple">
<li><p>C: <code class="code custom-cpp"><span class="pp-hash">#</span><span class="pp-directive">define</span> <span class="pp-macro">ARRAY_SIZE</span> <span class="lit-num">10</span></code> - macros are the only practical solution</p></li>
<li><p>C++ &lt; 11: <code class="code custom-cpp"><span class="keyword">const</span> <span class="keyword">int</span> <span class="var-local">array_size</span> = <span class="lit-num">10</span>;</code> - rely on special rules intended for constant expressions</p></li>
<li><p>C++ &gt;= 11: <code class="code custom-cpp"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="var-local">array_size</span> = <span class="lit-num">10</span>;</code> - use dedicated feature for constant expressions</p></li>
</ul>
<p>I don't want you to remember all these special rules - there are too many of them and their practical value exists pretty much only for compiler implementers, but just to illustrate - in the example below both <code class="code custom-cpp"><span class="var-local">n2</span></code> and <code class="code custom-cpp"><span class="var-local">n3</span></code> are const-qualified objects, but only <code class="code custom-cpp"><span class="var-local">n2</span></code> is classified as a constant expression.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="var-local">n1</span> = <span class="lit-num">10</span>;
<span class="keyword">const</span> <span class="keyword">int</span> <span class="var-local">n2</span> = <span class="lit-num">10</span>;
<span class="keyword">const</span> <span class="keyword">int</span> <span class="var-local">n3</span> = <span class="func">non_constexpr_function</span>();

<span class="keyword">int</span> <span class="var-local">arr1</span>[<span class="var-local">n1</span>]; <span class="com-single">// ok</span>
<span class="keyword">int</span> <span class="var-local">arr2</span>[<span class="var-local">n2</span>]; <span class="com-single">// also ok (n2 can be evaluated at compile time)</span>
<span class="keyword">int</span> <span class="var-local">arr3</span>[<span class="var-local">n3</span>]; <span class="com-single">// error: size not a constant expression</span>

<span class="keyword">int</span> <span class="var-local">n4</span> = <span class="lit-num">10</span>;
<span class="keyword">const</span> <span class="keyword">int</span> <span class="var-local">n5</span> = <span class="var-local">n4</span>; <span class="com-single">// const, but not compile time</span>
<span class="keyword">int</span> <span class="var-local">arr5</span>[<span class="var-local">n5</span>]; <span class="com-single">// error: n5 is not a constant expression</span>
</pre></td>
</tr></tbody></table>
<p>My recommendation is to use <code class="code custom-cpp"><span class="keyword">constexpr</span></code> and then you don't need to remember all these special rules - they were made to elevate <code class="code custom-cpp"><span class="keyword">const</span></code> before <code class="code custom-cpp"><span class="keyword">constexpr</span></code> was introduced into the language. In C, text-replacing macros have to be used as there is no way to make a constant expression other than writing the literal (obviously C++ code which uses macro for constants is bad code).</p>
<aside class="admonition note"><p class="admonition-title">note</p>
<p>Array size must be a constant expression but when indexing, the index can be computed at runtime.</p>
</aside><aside class="admonition note"><p class="admonition-title">note</p>
<p>Array size must be greater than 0.</p>
</aside><aside class="admonition note"><p class="admonition-title">note</p>
<p>Some compilers allow arrays of size 0 as the last member of a <code class="code custom-cpp"><span class="keyword">struct</span></code>, but this is a non-standard extension known as <em>flexible array member</em>. See <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html">GCC description of the feature</a>.</p>
</aside><aside class="admonition note"><p class="admonition-title">note</p>
<p>Before C11 and C++11 introduced <em>static assertions</em> (conditions checked at compile time), people have been using preprocessor tricks to create an (in)valid expression that would stop the build if the tested value (did not) met certain criteria. Most popular ones are macros which try to declare an array or a <em>bit-field</em> with invalid (0 or lower) size. See <a class="reference external" href="https://stackoverflow.com/questions/9229601/what-is-in-c-code">https://stackoverflow.com/questions/9229601/what-is-in-c-code</a> for a good example.</p>
</aside></section><section id="vla"><h2>VLA</h2>
<p>During some experiments, you might accidentally use a common extension known as <strong>variable length arrays</strong>. It permits code such as this:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">int</span> <span class="var-local">n</span>;
<span class="namespace">std</span>::<span class="var-global">cin</span> <span class="oo">&gt;&gt;</span> <span class="var-local">n</span>;
<span class="keyword">int</span> <span class="var-local">arr</span>[<span class="var-local">n</span>];
</pre></td>
</tr></tbody></table>
<p><strong>This is not standard C++.</strong> The feature dates back to C89, but even in C99 it was changed from "official" to "optional" and later removed in C11. C++ never officially had VLA, some compilers simply continued to support it as a non-standard extension. Modern compilers (with standard options) should reject such code or at least output a warning.</p>
<blockquote>
<p>Why was it removed from C and never was a part of C++? It seems useful.</p>
</blockquote>
<p>There are multiple reasons:</p>
<ul class="simple">
<li><p>VLA does runtime computation of stack allocation, which is very unsafe. There is no easy way to detect any failures with such operation and programs which invoke undefined behavior due to stack corruption are very prone to security exploits.</p></li>
<li><p>The same functionality (arrays with runtime changeable size) is available through dynamic memory allocation (you will learn about <code class="code custom-cpp"><span class="namespace">std</span>::<span class="type">vector</span></code> later in this chapter) and to some extent with preallocated fixed-size arrays.</p></li>
<li><p>The performance gain of VLA (compared to alternatives) is negligible.</p></li>
</ul></section><section id="initialization"><h2>Initialization</h2>
<p>Arrays can be initialized in multiple ways. You don't need to remember how every initialization is named (hardly anyone does), it's much more important to know their effect.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="var-local">n</span> = <span class="lit-num">5</span>;
<span class="keyword">int</span> <span class="var-local">arr1</span>[<span class="var-local">n</span>]; <span class="com-single">// uninitialized</span>
<span class="keyword">int</span> <span class="var-local">arr2</span>[<span class="var-local">n</span>] = {}; <span class="com-single">// each element is zero-initialized</span>
<span class="keyword">int</span> <span class="var-local">arr3</span>[<span class="var-local">n</span>] = {<span class="lit-num">1</span>, <span class="lit-num">2</span>}; <span class="com-single">// first 2 elements initialized explicitly, rest are zero-initialized</span>
<span class="keyword">int</span> <span class="var-local">arr4</span>[<span class="var-local">n</span>] = {<span class="lit-num">1</span>, <span class="lit-num">2</span>, <span class="lit-num">3</span>, <span class="lit-num">4</span>, <span class="lit-num">5</span>, <span class="lit-num">6</span>}; <span class="com-single">// ill-formed: too many initializers</span>

<span class="com-single">// array size can be inferred if it contains a non-empty initializer:</span>
<span class="keyword">int</span> <span class="var-local">arr</span>[] = {<span class="lit-num">1</span>, <span class="lit-num">2</span>, <span class="lit-num">3</span>}; <span class="com-single">// ok: arr has type int[3]</span>
</pre></td>
</tr></tbody></table></section><section id="array-size-1"><h2>Array size</h2>
<p>Because of how arrays work and how they occupy space in memory, there is a simple trick to compute their size:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">int</span> <span class="var-local">arr</span>[] = {<span class="lit-num">1</span>, <span class="lit-num">2</span>, <span class="lit-num">3</span>};
<span class="com-single">// size = number of bytes that array occupies / number of bytes per element</span>
<span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="var-local">sz</span> = <span class="keyword">sizeof</span>(<span class="var-local">arr</span>) / <span class="keyword">sizeof</span>(<span class="var-local">arr</span>[<span class="lit-num">0</span>]);
</pre></td>
</tr></tbody></table>
<p>Since C++17 the same can be done using a standard function:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="com-single">// std::size is available in many headers, including &lt;array&gt;</span>
<span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="var-local">sz</span> = <span class="namespace">std</span>::<span class="func">size</span>(<span class="var-local">arr</span>);
</pre></td>
</tr></tbody></table>
<p>And before C++17, the function could be written in C++11-compatible code. This function doesn't use <code class="code custom-cpp"><span class="keyword">sizeof</span></code> operator but the fact that templates can <em>deduce</em> array size from its type (<em>template type deduction</em> is a very powerful feature where the compiler can infer a lot of compile-time information):</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="param-tmpl">T</span>, <span class="namespace">std</span>::<span class="type">size_t</span> <span class="param-tmpl">N</span>&gt;
<span class="keyword">constexpr</span> <span class="namespace">std</span>::<span class="type">size_t</span> <span class="func">size</span>(<span class="keyword">const</span> <span class="param-tmpl">T</span> (&amp;)[<span class="param-tmpl">N</span>]) <span class="keyword">noexcept</span>
{
	<span class="keyword">return</span> <span class="param-tmpl">N</span>;
}
</pre></td>
</tr></tbody></table></section><section id="working-with-arrays"><h2>Working with arrays</h2>
<p>Since arrays are variables that refer to multiple objects you will pretty much always use loops to work with them, especially the <code class="code custom-cpp"><span class="keyword">for</span></code> loop. Now you should be able to see how well a <code class="code custom-cpp"><span class="keyword">for</span></code> loop is tied to arrays:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="pp-hash">#</span><span class="pp-directive">include</span> <span class="pp-header">&lt;iostream&gt;</span>

<span class="keyword">int</span> <span class="func">main</span>()
{
	<span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="var-local">sz</span> = <span class="lit-num">10</span>;
	<span class="keyword">int</span> <span class="var-local">powers</span>[<span class="var-local">sz</span>] = {};

	<span class="com-single">// the most idiomatic and classic loop that handles an array</span>
	<span class="com-single">// in almost all situations, i should not be modified inside loop body</span>
	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="var-local">i</span> = <span class="lit-num">0</span>; <span class="var-local">i</span> &lt; <span class="var-local">sz</span>; ++<span class="var-local">i</span>)
	{
		<span class="com-single">// reminder: &lt;&lt; here is bit shift operator</span>
		<span class="com-single">// shifting 1 will create different powers of 2</span>
		<span class="var-local">powers</span>[<span class="var-local">i</span>] = <span class="lit-num">1</span> <span class="oo">&lt;&lt;</span> <span class="var-local">i</span>;
	}

	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="var-local">i</span> = <span class="lit-num">0</span>; <span class="var-local">i</span> &lt; <span class="var-local">sz</span>; ++<span class="var-local">i</span>)
		<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="var-local">powers</span>[<span class="var-local">i</span>] <span class="oo">&lt;&lt;</span> <span class="lit-str">", "</span>;
}
</pre></td>
</tr></tbody></table>
<p>Notice how exactly the loop is written:</p>
<ul class="simple">
<li><p>it starts with <code class="code custom-cpp"><span class="lit-num">0</span></code></p></li>
<li><p>the condition is <code class="code custom-cpp">&lt;</code></p></li>
<li><p>it uses preincrement (postfix would work too but we don't need an extra copy of old <code class="code custom-cpp"><span class="var-local">i</span></code>)</p></li>
</ul>
<p>A common mistake is writing loop condition with <code class="code custom-cpp">&lt;=</code>. For an array of size <code class="docutils literal">n</code>, valid indexes are <code class="docutils literal">0 ... <span class="pre">n-1</span></code>, thus the loop should continue only when <code class="code custom-cpp"><span class="var-local">i</span></code> is lower than the size. Rarely you might find <code class="code custom-cpp">!=</code>, which is also valid but such code is usually written when working with <em>iterators</em> which will be covered later.</p>
<p>Whichever of <code class="code custom-cpp">&lt;</code> and <code class="code custom-cpp">!=</code> operators is used, after last iteration the loop control variable (<code class="code custom-cpp"><span class="var-local">i</span></code>) will be equal to array size and stop the loop. Iteration with <code class="code custom-cpp"><span class="var-local">i</span></code> equal to array size will never happen.</p>
</section><section id="loop-control-vs-array-size-type"><h2>Loop control vs array size type</h2>
<p>The C++ standard library uses size type (<code class="code custom-cpp"><span class="namespace">std</span>::<span class="type">size_t</span></code>) for array sizes. For historical reasons, this type is an alias of some unsigned integer (typically <code class="code custom-cpp"><span class="keyword">unsigned</span> <span class="keyword">long</span></code> or <code class="code custom-cpp"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span></code>) which as you should remember is not a good choice - unsigned types should only be used when dealing with bit-level operations or when overflow is desired.</p>
<p>This causes a quite common warning:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="pp-hash">#</span><span class="pp-directive">include</span> <span class="pp-header">&lt;iostream&gt;</span>

<span class="keyword">int</span> <span class="func">main</span>()
{
	<span class="keyword">int</span> <span class="var-local">arr</span>[] = {<span class="lit-num">1</span>, <span class="lit-num">2</span>, <span class="lit-num">3</span>};

	<span class="com-single">// auto deduced to std::size_t</span>
	<span class="com-single">// std::size(arr) would deduce auto as std::size_t too</span>
	<span class="keyword">const</span> <span class="keyword">auto</span> <span class="var-local">sz</span> = <span class="keyword">sizeof</span>(<span class="var-local">arr</span>) / <span class="keyword">sizeof</span>(<span class="var-local">arr</span>[<span class="lit-num">0</span>]);

	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="var-local">i</span> = <span class="lit-num">0</span>; <span class="var-local">i</span> &lt; <span class="var-local">sz</span>; ++<span class="var-local">i</span>)
		<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="var-local">arr</span>[<span class="var-local">i</span>];
}
</pre></td>
</tr></tbody></table>
<pre class="code ansi"><span class="ansi1">main.cpp:</span> In function ‘<span class="ansi1">int main()</span>’:
<span class="ansi1">main.cpp:11:20:</span> <span class="ansi1 ansi35">warning: </span>comparison of integer expressions of different signedness: ‘<span class="ansi1">int</span>’ and ‘<span class="ansi1">long unsigned int</span>’ [<span class="ansi1 ansi35">-Wsign-compare</span>]
  for (int i = 0; <span class="ansi1 ansi35">i &lt; sz</span>; ++i)
                  <span class="ansi1 ansi35">~~^~~~</span>
</pre>
<p>Most beginners will find this warning hard to understand. What's the problem here? Can't the compiler generate code that converts one integer to the type of another and then compare them?</p>
<p>It can. The problem is, the resulting behavior can be very surprising. The prime example is the expression <code class="code custom-cpp">-<span class="lit-num">1</span> &lt; <span class="lit-num">1</span>u</code>. Obviously -1 is smaller than 1 but surprisingly the expression evaluates to <code class="code custom-cpp"><span class="keyword">false</span></code>. Why?</p>
<p>The cause are convertion rules. Promotion is preferred so if you compare e.g. <code class="code custom-cpp"><span class="keyword">int</span></code> with <code class="code custom-cpp"><span class="keyword">long</span></code> there will be no problem as the first one will be promoted and the comparison will happen between 2 long integers. But in the case of <code class="code custom-cpp">-<span class="lit-num">1</span> &lt; <span class="lit-num">1</span>u</code>, there is no promotion because both integers are of the same size: <code class="code custom-cpp"><span class="keyword">int</span></code> (AKA <code class="code custom-cpp"><span class="keyword">signed</span></code>) and <code class="code custom-cpp"><span class="keyword">unsigned</span></code>. One must be converted to another and in both cases there is a risk that final value will not fit:</p>
<ul class="simple">
<li><p>convert to signed: huge values will not fit</p></li>
<li><p>convert to unsigned: negative values will not fit</p></li>
</ul>
<p>For historical reasons, convertion to <code class="code custom-cpp"><span class="keyword">unsigned</span></code> takes place. Because of how integer convertions work, value <code class="code custom-cpp">-<span class="lit-num">1</span></code> will be interpreted as the largest possible value representable in unsigned type (modulo 2 arithmetic), causing an operation like 4294967296 &lt; 1. In other words: <strong>if you compare signed with unsigned and the signed value is negative, the comparison will evaluate to :cch:`false`</strong>. This is a common source of bugs in loops.</p>
<p>The solution is simple: make sure both comparison operands are of the same type. Usually it's as simple as changing the type of <code class="code custom-cpp"><span class="var-local">i</span></code>, which is on the same line as the warning. Since C++20 there is also another small help: <code class="code custom-cpp"><span class="namespace">std</span>::<span class="func">ssize</span></code> member functions with the same name. These work just like <code class="code custom-cpp"><span class="namespace">std</span>::<span class="func">size</span></code> but their return type is a signed version of <cite>std::size_t</cite>, called <code class="code custom-cpp"><span class="namespace">std</span>::<span class="type">ptrdiff_t</span></code> (pointer difference type). Later you will also learn about other typical forms of loops (range-based, iterator-based) which do not have this problem.</p>
<aside class="admonition tip"><p class="admonition-title">tip</p>
<p>Avoid using different types for loop counters and sizes.</p>
</aside><!--  --><blockquote>
<p>What if I can not change the types?</p>
</blockquote>
<p>In such case use a <code class="code custom-cpp"><span class="keyword">static_cast</span></code> to convert values before comparison. TODO which convert to which? both to signed or both to unsigned?</p>
</section><section id="looping-backwards"><h2>Looping backwards</h2>
<p>Some algorithms need to work on the array in reverse order. A typical loop would look then like this:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">for</span> (<span class="keyword">int</span> <span class="var-local">i</span> = <span class="var-local">sz</span> - <span class="lit-num">1</span>; <span class="var-local">i</span> &gt;= <span class="lit-num">0</span>; --<span class="var-local">i</span>)
</pre></td>
</tr></tbody></table>
<p>This is fine, but breaks when <code class="code custom-cpp"><span class="var-local">i</span></code> is of unsigned type as for unsigned types condition <code class="code custom-cpp"><span class="var-local">i</span> &gt;= <span class="lit-num">0</span></code> is always true as they can not represent negative numbers (<code class="code custom-cpp">--<span class="var-local">i</span></code> on zero will overflow to the largest possible value).</p>
<p>It's possible to loop backward on an unsigned control variable, but one needs to do a little trick to change the order of operations:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="com-single">// start with sz (which is out of bounds)</span>
<span class="com-single">// but decrement i after each comparison, not after each iteration</span>
<span class="com-single">// this loop will also work on signed types</span>
<span class="keyword">for</span> (<span class="namespace">std</span>::<span class="type">size_t</span> <span class="var-local">i</span> = <span class="var-local">sz</span>; <span class="var-local">i</span>-- &gt; <span class="lit-num">0</span>;)
</pre></td>
</tr></tbody></table>
<p>Related: <a class="reference external" href="https://stackoverflow.com/questions/1642028">SO: What is the "--&gt;" operator in C++?</a>.</p>
</section><section id="passing-arrays"><h2>Passing arrays</h2>
<p>Do you remember that function argument types strip top-level <code class="code custom-cpp"><span class="keyword">const</span></code> (a part of a set of implicit convertions, known as <em>decay</em>)?</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">void</span> <span class="func">func</span>(<span class="keyword">const</span> <span class="keyword">int</span> <span class="param">value</span>);
<span class="keyword">void</span> <span class="func">func</span>(<span class="keyword">int</span> <span class="param">value</span>); <span class="com-single">// equivalent</span>

<span class="keyword">void</span> <span class="func">func</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> <span class="param">str</span>);
<span class="keyword">void</span> <span class="func">func</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="param">str</span>); <span class="com-single">// equivalent</span>
</pre></td>
</tr></tbody></table>
<p>This is also true for array types. The array type itself (including size information) is removed and the only thing that is left is a pointer:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">int</span> <span class="param">arr</span>[<span class="lit-num">3</span>]); <span class="com-single">// array argument of size 3</span>
<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">int</span> <span class="param">arr</span>[]);  <span class="com-single">// array argument of unspecified size</span>

<span class="com-single">// both above are equivalent to this</span>
<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">int</span>* <span class="param">arr</span>); <span class="com-single">// pointer argument</span>

<span class="com-single">// this is something different (VLA argument) and applies only to C</span>
<span class="com-single">// since C++ (officially) has no VLAs, this is a syntax error</span>
<span class="keyword">void</span> <span class="func">f</span>(<span class="keyword">int</span> <span class="param">arr</span>[*]);
</pre></td>
</tr></tbody></table>
<p>The function declaration can use array declaration syntax for informational purposes but it has no semantic difference.</p>
<p>Since the array type is lost, the convention of passing arrays to functions is to pass the pointer and a size (often <code class="code custom-cpp"><span class="namespace">std</span>::<span class="type">size_t</span></code>). A benefit of this approach is that a function can work with multiple arrays of different sizes, only the type of objects within the array must match. In C++20 there is also a dedicated type for it - <code class="code custom-cpp"><span class="namespace">std</span>::<span class="type">span</span></code>.</p>
<p>Pointers are a complicated topic that will be explained later. For now, it's enough to understand that:</p>
<ul class="simple">
<li><p>arrays <em>decay</em> into pointers (memory addresses)</p></li>
<li><p>operator <code class="docutils literal">[]</code> is actually defined for pointers, not arrays</p></li>
</ul>
<p>This means that once within a function, you can work with arrays exactly the same way:</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="pp-hash">#</span><span class="pp-directive">include</span> <span class="pp-header">&lt;iostream&gt;</span>

<span class="com-single">// in C++17 you can remove this and use std::size</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="param-tmpl">T</span>, <span class="keyword">int</span> <span class="param-tmpl">N</span>&gt;
<span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="func">size</span>(<span class="keyword">const</span> <span class="param-tmpl">T</span> (&amp;)[<span class="param-tmpl">N</span>]) <span class="keyword">noexcept</span>
{
	<span class="keyword">return</span> <span class="param-tmpl">N</span>;
}

<span class="keyword">void</span> <span class="func">print</span>(<span class="keyword">const</span> <span class="keyword">int</span>* <span class="param">arr</span>, <span class="keyword">int</span> <span class="param">size</span>)
{
	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="var-local">i</span> = <span class="lit-num">0</span>; <span class="var-local">i</span> &lt; <span class="param">size</span>; ++<span class="var-local">i</span>)
		<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="param">arr</span>[<span class="var-local">i</span>] <span class="oo">&lt;&lt;</span> <span class="lit-str">", "</span>;

	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="lit-str">"<span class="esc-seq">\n</span>"</span>;
}

<span class="keyword">int</span> <span class="func">main</span>()
{
	<span class="keyword">int</span> <span class="var-local">arr1</span>[] = {<span class="lit-num">1</span>, <span class="lit-num">2</span>, <span class="lit-num">3</span>};
	<span class="keyword">int</span> <span class="var-local">arr2</span>[] = {<span class="lit-num">3</span>, <span class="lit-num">1</span>, <span class="lit-num">3</span>, <span class="lit-num">3</span>, <span class="lit-num">7</span>};

	<span class="func">print</span>(<span class="var-local">arr1</span>, <span class="func">size</span>(<span class="var-local">arr1</span>));
	<span class="func">print</span>(<span class="var-local">arr2</span>, <span class="func">size</span>(<span class="var-local">arr2</span>));
}
</pre></td>
</tr></tbody></table>
<p>You might wonder why. After all, it's possible to compute array size with the <code class="code custom-cpp"><span class="keyword">sizeof</span></code> operator, right? That's true, <strong>but only for array types</strong>. Inside the function you don't have an array, only a pointer! In other words, because <em>decay</em> strips some type information, it's not possible to compute the size of the array after it.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">int</span> <span class="var-local">arr</span>[] = {<span class="lit-num">1</span>, <span class="lit-num">2</span>, <span class="lit-num">3</span>, <span class="lit-num">4</span>, <span class="lit-num">5</span>, <span class="lit-num">6</span>};
<span class="com-single">// ok: sizeof(array) / sizeof(element)</span>
<span class="keyword">const</span> <span class="keyword">auto</span> <span class="var-local">sz1</span> = <span class="keyword">sizeof</span>(<span class="var-local">arr</span>) / <span class="keyword">sizeof</span>(<span class="var-local">arr</span>[<span class="lit-num">0</span>]);

<span class="com-single">// this is what happens when an array is passed to a function</span>
<span class="keyword">const</span> <span class="keyword">int</span>* <span class="var-local">ptr</span> = <span class="var-local">arr</span>; <span class="com-single">// some type information is lost</span>
<span class="com-single">// wrong: sizeof(pointer) / sizeof(element)</span>
<span class="keyword">const</span> <span class="keyword">auto</span> <span class="var-local">sz2</span> = <span class="keyword">sizeof</span>(<span class="var-local">ptr</span>) / <span class="keyword">sizeof</span>(<span class="var-local">ptr</span>[<span class="lit-num">0</span>]);
</pre></td>
</tr></tbody></table>
<aside class="admonition tip"><p class="admonition-title">tip</p>
<p>When writing a function that takes an array, never assume it's of certain size. Always pass array size to the function. Otherwise code clarity and flexibility is significantly reduced.</p>
</aside></section><section id="array-limitations"><h2>Array limitations</h2>
<p>The syntax of arrays in C++ has been inherited from C and various rules regarding array-related operations were too. Sadly, for backward compatibility reasons they have to remain as they were specified in C.</p>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">int</span> <span class="var-local">arr1</span>[<span class="lit-num">5</span>] = {<span class="lit-num">1</span>, <span class="lit-num">2</span>, <span class="lit-num">3</span>, <span class="lit-num">4</span>, <span class="lit-num">5</span>};
<span class="keyword">int</span> <span class="var-local">arr2</span>[<span class="lit-num">5</span>] = {<span class="lit-num">1</span>, <span class="lit-num">2</span>, <span class="lit-num">3</span>, <span class="lit-num">4</span>, <span class="lit-num">5</span>};
<span class="keyword">int</span> <span class="var-local">arr3</span>[<span class="lit-num">5</span>] = <span class="var-local">arr2</span>; <span class="com-single">// error: arrays can not be assigned to or initialized with other arrays</span>

<span class="com-single">// workaround</span>
<span class="keyword">struct</span> <span class="type">sarr</span> { <span class="keyword">int</span> <span class="var-local">arr</span>[<span class="lit-num">5</span>]; };
<span class="type">sarr</span> <span class="var-local">s1</span> = {<span class="lit-num">1</span>, <span class="lit-num">2</span>, <span class="lit-num">3</span>, <span class="lit-num">4</span>, <span class="lit-num">5</span>};
<span class="type">sarr</span> <span class="var-local">s2</span> = <span class="var-local">s1</span>; <span class="com-single">// ok</span>

<span class="com-single">// this will compile, but behaves differently than expected</span>
<span class="com-single">// it will compare memory adresses of arrays, not their contents</span>
<span class="com-single">// may print a warning that comparison is always false</span>
<span class="keyword">bool</span> <span class="var-local">b</span> = <span class="var-local">arr1</span> == <span class="var-local">arr2</span>;
</pre></td>
</tr></tbody></table>
<p>Arrays can not be copied, but structures can. Yes, kind of stupid. Soon you will learn about <code class="code custom-cpp"><span class="namespace">std</span>::<span class="type">array</span></code> (the proper C++ array) which does not have such limitations.</p>
</section><section id="exercise"><h2>Exercise</h2>
<ul class="simple">
<li><p>Write a function that copies contents of one array to another.</p></li>
<li><p>Write a function that reverses order of elements in an array.</p></li>
<li><p>Write a function that compares whether 2 arrays are identical.</p></li>
<li><p>Call <code class="code custom-cpp"><span class="func">reverse</span></code> twice and verify that array is identical to the state before reversal.</p></li>
</ul>
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="pp-hash">#</span><span class="pp-directive">include</span> <span class="pp-header">&lt;iostream&gt;</span>

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="param-tmpl">T</span>, <span class="keyword">int</span> <span class="param-tmpl">N</span>&gt;
<span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="func">size</span>(<span class="keyword">const</span> <span class="param-tmpl">T</span> (&amp;)[<span class="param-tmpl">N</span>]) <span class="keyword">noexcept</span>
{
	<span class="keyword">return</span> <span class="param-tmpl">N</span>;
}

<span class="keyword">void</span> <span class="func">copy</span>(<span class="keyword">const</span> <span class="keyword">int</span>* <span class="param">input</span>, <span class="keyword">int</span>* <span class="param">output</span>, <span class="keyword">int</span> <span class="param">size</span>)
{

}

<span class="keyword">void</span> <span class="func">reverse</span>(<span class="keyword">int</span>* <span class="param">arr</span>, <span class="keyword">int</span> <span class="param">size</span>)
{

}

<span class="keyword">bool</span> <span class="func">compare</span>(<span class="keyword">const</span> <span class="keyword">int</span>* <span class="param">lhs_arr</span>, <span class="keyword">int</span> <span class="param">lhs_size</span>, <span class="keyword">const</span> <span class="keyword">int</span>* <span class="param">rhs_arr</span>, <span class="keyword">int</span> <span class="param">rhs_size</span>)
{

}

<span class="keyword">int</span> <span class="func">main</span>()
{
	<span class="keyword">int</span> <span class="var-local">arr1</span>[] = {<span class="lit-num">1</span>, <span class="lit-num">1</span>, <span class="lit-num">2</span>, <span class="lit-num">3</span>, <span class="lit-num">5</span>, <span class="lit-num">8</span>, <span class="lit-num">13</span>, <span class="lit-num">21</span>, <span class="lit-num">34</span>, <span class="lit-num">55</span>, <span class="lit-num">89</span>};
	<span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="var-local">sz</span> = <span class="func">size</span>(<span class="var-local">arr1</span>);
	<span class="keyword">int</span> <span class="var-local">arr2</span>[<span class="var-local">sz</span>] = {};

	<span class="func">copy</span>(<span class="var-local">arr1</span>, <span class="var-local">arr2</span>, <span class="var-local">sz</span>);
	<span class="func">reverse</span>(<span class="var-local">arr2</span>, <span class="var-local">sz</span>);
	<span class="func">reverse</span>(<span class="var-local">arr2</span>, <span class="var-local">sz</span>);
	<span class="namespace">std</span>::<span class="var-global">cout</span> <span class="oo">&lt;&lt;</span> <span class="namespace">std</span>::<span class="func">boolalpha</span> <span class="oo">&lt;&lt;</span> <span class="func">compare</span>(<span class="var-local">arr1</span>, <span class="var-local">sz</span>, <span class="var-local">arr2</span>, <span class="var-local">sz</span>);
}
</pre></td>
</tr></tbody></table>
<p>The <code class="code custom-cpp"><span class="func">compare</span></code> takes 2 sizes intentionally. In practice, if you are copying you must be sure that the output array is at least as large as the input array. But for comparison, you could obtain 2 different arrays from 2 different places. This extra check is not needed for this exercise but all functions showcase canonical way they would be defined.</p>
<div class="docutils container">
<details><summary>reversal algorithm hint</summary><div class="docutils container">
<p>Inside the function, you don't need to make array copy or anything similar. Just swap pairs of elements that have identical distance from array ends.</p>
</div>
</details>
</div>
<div class="docutils container">
<details><summary>solution</summary><div class="docutils container">
<table class="codetable"><tbody><tr>
<td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></div></td>
<td class="code"><pre class="code custom-cpp"><span class="keyword">void</span> <span class="func">copy</span>(<span class="keyword">const</span> <span class="keyword">int</span>* <span class="param">input</span>, <span class="keyword">int</span>* <span class="param">output</span>, <span class="keyword">int</span> <span class="param">size</span>)
{
	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="var-local">i</span> = <span class="lit-num">0</span>; <span class="var-local">i</span> &lt; <span class="param">size</span>; ++<span class="var-local">i</span>)
		<span class="param">output</span>[<span class="var-local">i</span>] = <span class="param">input</span>[<span class="var-local">i</span>];
}

<span class="keyword">void</span> <span class="func">reverse</span>(<span class="keyword">int</span>* <span class="param">arr</span>, <span class="keyword">int</span> <span class="param">size</span>)
{
	<span class="keyword">const</span> <span class="keyword">int</span> <span class="var-local">n</span> = <span class="param">size</span> / <span class="lit-num">2</span>;
	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="var-local">i</span> = <span class="lit-num">0</span>; <span class="var-local">i</span> &lt; <span class="var-local">n</span>; ++<span class="var-local">i</span>)
	{
		<span class="keyword">int</span> <span class="var-local">temp</span> = <span class="param">arr</span>[<span class="var-local">i</span>];
		<span class="param">arr</span>[<span class="var-local">i</span>] = <span class="param">arr</span>[<span class="param">size</span> - <span class="var-local">i</span> - <span class="lit-num">1</span>];
		<span class="param">arr</span>[<span class="param">size</span> - <span class="var-local">i</span> - <span class="lit-num">1</span>] = <span class="var-local">temp</span>;

		<span class="com-single">// the loop body could also be this</span>
		<span class="com-single">// std::swap(arr[i], arr[size - i - 1]);</span>
	}
}

<span class="keyword">bool</span> <span class="func">compare</span>(<span class="keyword">const</span> <span class="keyword">int</span>* <span class="param">lhs_arr</span>, <span class="keyword">int</span> <span class="param">lhs_size</span>, <span class="keyword">const</span> <span class="keyword">int</span>* <span class="param">rhs_arr</span>, <span class="keyword">int</span> <span class="param">rhs_size</span>)
{
	<span class="com-single">// if sizes are different, there is no point in going further</span>
	<span class="keyword">if</span> (<span class="param">lhs_size</span> != <span class="param">rhs_size</span>)
		<span class="keyword">return</span> <span class="keyword">false</span>;

	<span class="com-single">// now we can use just 1 variable for counting as both sizes must be the same</span>
	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="var-local">i</span> = <span class="lit-num">0</span>; <span class="var-local">i</span> &lt; <span class="param">lhs_size</span>; ++<span class="var-local">i</span>)
		<span class="keyword">if</span> (<span class="param">lhs_arr</span>[<span class="var-local">i</span>] != <span class="param">rhs_arr</span>[<span class="var-local">i</span>])
			<span class="keyword">return</span> <span class="keyword">false</span>;

	<span class="keyword">return</span> <span class="keyword">true</span>;
}
</pre></td>
</tr></tbody></table>
</div>
</details>
</div>
</section>
</div>
 		<footer class="footer"><div class="footer-item footer-item-container">
				<div class="footer-flex-item">
					<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">
						<img alt="Creative Commons License" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a>
					<br>
					All non-code content licensed under <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, unless stated otherwise.
				</div>
				<div class="footer-flex-item">
					All code content (monospaced font) licensed under <a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/">Creative Commons Zero License</a>, unless stated otherwise.
				</div>
			</div>
			<div class="footer-item footer-item-container">
				<div class="footer-flex-item">
					Generated using heavily customized <a href="https://getnikola.com">Nikola</a> static site generator.
				</div>
				<div class="footer-flex-item">
					<a href="https://github.com/Xeverous/the_website">website repository and issue tracker</a>
				</div>
			</div>
		</footer>
</div>
	</div>
</body>
</html>
